Вторая часть коспекта, из-за ограничей Github был разделен единый файл коспекта на части.
[Вернуться к первой части коспекта](https://github.com/artemiosdev/Swift-Manual-my-notes)

<a id="contents" />Оглавление

- [Глава  №13. Замыкания (closure). ](#chapter13)
- [Глава  №14. Дополнительные возможности. Методы. ](#chapter14)
- [Глава  №15. Ленивые вычисления. ](#chapter15)

Часть IV ВВЕДЕНИЕ В РАЗРАБОТКУ ПРИЛОЖЕНИЙ

- [Глава  №16. Консольные приложения. ](#chapter16)
- [Глава  №17. Консольные приложение "Угадай число". ](#chapter17)
- [Глава  №18. Введение в объектно-ориентированное и протокол-ориентированное программирование. ](#chapter18)
- [Глава  №19. . ](#chapter19)
- [Глава  №20. . ](#chapter20)
- [Глава  №21. . ](#chapter21)
- [Глава  №22. . ](#chapter22)
- [Глава  №23. . ](#chapter23)
- [Глава  №24. . ](#chapter24)
- [Глава  №25. . ](#chapter25)
- [Глава  №26. . ](#chapter26)
- [Глава  №27. . ](#chapter27)

[К оглавлению](#contents)

###  <a id="chapter11" /> Глава №11. Опциональные типы данных 

Когда вы объявляете какой-либо параметр, например `var name: String`, то с ним ассоциируется определенное значение, например Artem, которое всегда возвращается по имени данного параметра. Значение всегда имеет определенный тип, даже если это пустая строка, пустой массив и т. д. Это одна из функций безопасного программирования в Swift: если объявлен параметр определенного типа, то при обращении к нему вы **гарантированно** получите значение этого типа 

Опциональные типы данных, или `#опционалы` `#optional`, — это особый тип, который говорит о том, что **параметр либо имеет значение определенного типа, либо вообще не имеет никакого значения**. Иногда очень полезно оперировать отсутствием значения.

Think of an optional as a box: it either contains exactly one value, or is empty. When it doesn’t contain a value, it’s said to contain nil. The box itself always exists; it’s always there for you to open and look inside.

Optional variables and constants are like boxes that can contain a value or be empty (nil).

**Пример 1** 

Представьте, что перед вами бесконечная двумерная плоскость (с двумя осями координат). В ходе эксперимента на ней устанавливают точку с координатами `x=0` и `y=0`, которые в коде могут быть представлены либо как два целочисленных параметра `(x:Int и y:Int)`, либо как кортеж типа `(Int, Int)`. В зависимости от ваших потребностей вы можете передвигать точку, изменяя ее координаты. В любой момент времени вы можете говорить об этой точке и получать конкретные значения x и y. 

Что произойдет, если убрать точку с плоскости? Она все еще будет существовать в вашей программе, но при этом не будет иметь координат. Совершенно никаких координат. В данном случае x и y не могут быть установлены в том числе и в 0, так как 0 — это точно такая же координата, как и любая другая. 

Данная проблема может быть решена с помощью введения дополнительного параметра (например, `isSet: Bool`), определяющего, установлена ли точка на плоскости. Если `isSet = true`, то можно производить операции с координатами точки, в ином случае считается, что точка не установлена на плоскости. При таком подходе велика вероятность ошибки, так как необходимо контролировать значение `isSet` и проверять его перед каждой операцией с точкой. 

В такой ситуации наиболее верным решением станет использование опционального типа данных в качестве типа значения, определяющего координаты точки. В случае, когда точка находится на плоскости, будут возвращаться конкретные целочисленные значения, а когда она убрана — специальное ключевое слово, определяющее отсутствие координат (а значит, и точки на плоскости). 

**Пример 2**

Ваша программа запрашивает у пользователя его имя, возраст и место работы. Если первые два параметра могут быть определены для любого пользователя, то конкретное рабочее место может отсутствовать. Конечно же, чтобы указать на то, что работы нет, можно использовать пустую строку, но опционалы, позволяющие определить отсутствие значения, являются наиболее правильным решением. Таким образом, обращаясь к переменной, содержащей место работы, вы будете получать либо конкретное строковое значение, либо специальное ключевое слово, сигнализирующее об отсутствии работы. 

Самое важное, чего позволяют достичь опционалы, — это исключение неоднозначности. **Если значение есть, то оно есть, если его нет, то оно не сравнивается с нулем или пустой строкой, его просто нет**. 

Важно не путать отсутствие какого-либо значения в опциональном типе данных с пустой строкой или нулем. Пустая строка — это обычный строковый литерал, то есть вполне конкретное значение переменной типа String, а ноль — вполне конкретное значение числового типа данных. То же относится и к пустым коллекциям. 

У вас мог возникнуть вопрос: как Swift показывает, что в параметре опционального типа отсутствует значение? Для этого используется ключевое слово `nil`. 

Ранее мы использовали функцию `Int(_:)` для создания и приведения целочисленных значений. Но не каждый переданный в нее литерал может быть преобразован к целочисленному типу данных: к примеру, строку 1945 можно конвертировать в число, а “Одна тысяча сто десять” вернуть в виде числа не получится 

```swift
let possibleString = "1945"
let convertPossibleString = Int(possibleString) // 1945
let unpossibleString = "Одна тысяча сто десять"
let convertUnpossibleString = Int(unpossibleString) // nil
```

При конвертации строкового значения 1945, состоящего только из цифр, возвращается число. А во втором случае возвращается ключевое слово `nil`, сообщающее о том, что в результате конвертации не получено никакого целочисленного значения. То есть это не ноль, это не пустая строка, а именно **отсутствие значения как такового**. 

Самое интересное, что в обоих случаях (и при числовом, и при строковом значении переданного аргумента) возвращается значение **опционального типа данных**. То есть 1945 — это значение не целочисленного, а опционального целочисленного типа данных. Также и `nil` — в данном примере это указатель на отсутствие значения в хранилище опционального целочисленного типа. 

В этом примере функция `Int(_:)` возвращает опционал, то есть значение такого типа данных, который может либо содержать конкретное значение (целое число), либо не содержать совершенно ничего (nil). 

Опционалы — это отдельная самостоятельная группа типов данных. Целочисленный тип и опциональный целочисленный тип — это два совершенно разных типа данных. По этой причине опционалы должны иметь собственное обозначение типа. И они его имеют. Убедимся в этом, определив тип данных констант из предыдущего листинга.

```swift
type(of: convertPossibleString)   // Optional<Int>.Type
type(of: convertUnpossibleString) // Optional<Int>.Type
```

`Optional<Int>` — это идентификатор опционального целочисленного типа данных, то есть значение такого типа может либо быть целым числом, либо отсутствовать полностью. Тип Int является базовым для этого опционала, то есть основан на типе Int. 

Более того, опциональные типы данных всегда строятся на основе базовых неопциональных. Они могут брать за основу совершенно любой тип данных, включая Bool, String, Float и Double, а также типы данных кортежей, ваши собственные типы, типы коллекций и т. д. 

Напомню, что опционалы являются самостоятельными типами, отличными от базовых, то есть тип `Int` и тип `Optional<Int>` — это два разных типа данных. 

Функция `Int(_:)` не всегда возвращает опционал, а лишь в том случае, если в нее передано нечисловое значение. Так, если в `Int(_:)` передается значение типа Double, то нет никакой необходимости возвращать опционал, так как при любом значении Double оно может быть преобразовано в Int (чего нельзя сказать про преобразование String в Int). 

Далее показано, что приведение String и Double к Int дает значения различных типов данных (Optional<Int> и Int). 

```swift
     let x1 = Int("12")
     type(of: x1) // Optional<Int>.Type
     let x2 = Int(43.2)
     type(of: x2) // Int.Type
```

В общем случае тип данных опционала имеет две формы записи. 

Полная форма записи: 
`Optional<T> `

Краткая форма записи: 
`T?`

`T: Any` — наименование типа данных, на котором основан опционал. 

При объявлении параметра, имеющего опциональный тип, необходимо явно указать его тип данных. Для этого можно использовать полную форму записи. Приведен пример объявления переменной опционального типа, основанного на Character. 

`let optionalChar: Optional<Character> = "a"`

При объявлении опционала Swift также позволяет использовать сокращенный синтаксис. Для этого в конце базового типа необходимо добавить знак вопроса ? , никаких других элементов не требуется. Таким образом, тип `Optional<Int>` может быть переписан в `Int?`, `Optional<String>` в `String?` и в любой другой тип. 

`var xCoordinate: Int? = 12`

В любой момент значение опционала может быть изменено на `nil`. Это можно сделать как и при объявлении параметра, так и потом 

```swift
xCoordinate // 12
xCoordinate = nil
xCoordinate // nil
```

Переменная `xCoordinate` является переменной опционального целочисленного типа данных `Int?`. Изначально ей было присвоено значение, соответствующее базовому для опционала типу данных, которое позже было заменено на `nil` (то есть значение переменной было уничтожено). 

Если объявить переменную опционального типа, но не проинициализировать ее значение, Swift по умолчан сочтет ее равной nil 

`var someOptional: Bool? // nil`

Для создания опционала помимо явного указания типа также можно использовать функцию `Optional(_:)`, в которую необходимо передать инициализируемое значение требуемого базового типа 

```swift
// опциональная переменная с установленным значением
var optionalVar = Optional("stringValue")       // "stringValue"
// уничтожаем значение опциональной переменной
optionalVar = nil // nil
type(of: optionalVar) // Optional<String>.Type
```

Так как в функцию `Optional(_:)` в качестве аргумента передано значение типа String, то возвращаемое ею значение имеет опциональный строковый тип данных `String?` (или `Optional<String>`, что является синонимами). 

Вы используете optional в ситуациях, когда значение может отсутствовать. Optionals параметр представляет две возможности: либо есть значение, и вы можете развернуть optionals элемент, чтобы получить доступ к этому значению, либо значение отсутствует вообще.
The example below uses the initializer to try to convert a String into an Int:

```swift
let possibleNumber = "123" 
let convertedNumber = Int(possibleNumber) 
// convertedNumber is inferred to be of type "Int?", or "optional Int" 
```

Поскольку инициализатор может выйти из строя, он возвращает optional  Int, а не  обычный Int. Optional  Int записывается как Int?, а не как Int. Знак вопроса указывает на то, что содержащееся в нем значение является optional , что означает, что оно может содержать некоторое значение типа Int или может вообще не содержать значения. Это либо Int, либо вообще ничего.

### nil 

```swift
var serverResponseCode: Int? = 404 // serverResponseCode contains an actual Int value of 404 
serverResponseCode = nil // serverResponseCode now contains no value 
```

Вы не можете использовать #nil с non-optional constants and variables. If a constant or variable in your code needs работать с отсутствием значения при определенных условиях, всегда объявляйте ее как optional значение соответствующего типа.
Если вы определяете optional var без указания значения по умолчанию, для этой переменной автоматически устанавливается значение `nil`

```swift
var surveyAnswer: String?  // surveyAnswer is automatically set to nil 
```

Значение nil в Swift – это не то же самое, что nil в Objective-C. В Objective-C nil – это указатель на несуществующий объект. В Swift `nil` не является указателем – это **отсутствие значения определенного типа**. Optional параметры любого типа могут иметь значение nil, а не только типы объектов

### Опционалы в кортежах 

```swift
var tuple: (code: Int, message: String)? = nil
tuple = (404, "Page not found") // (code 404, message "Page not found")
```

В этом примере опциональный тип основан на типе кортежа (Int, String).
При необходимости вы можете использовать опционал для отдельных элементов кортежей 

```swift
let tupleWithoptelements: (Int?, Int) = (nil, 100)
tupleWithoptelements.0 // nil
tupleWithoptelements.1 // 100
```

### Извлечение опционального значения 

Важно отметить, что нельзя производить прямые операции между значениями опционального и базового типов данных, будет ошибка.

```swift
let a: Int = 4
let b: Int? = 5
a + b // ОШИБКА. Несоответствие типов
```

В переменной `a` хранится значение неопционального типа Int, в то время как значение `b` является опциональным (Int?). 

It doesn’t work because you’re trying to add an integer to a box — not to the value inside the box, but to the box itself. That doesn’t make sense.

The error message indicates the solution: It tells you that the optional must be unwrapped (развернуть коробку, открыть и достать содержимое, извлечь его). You need to unwrap the value from its box. It’s like Christmas!

Типы Int? и Int, String? и String, Bool? и Bool – разные типы данных. Для решения проблемы их взаимодействия можно применить прием, называемый извлечением опционального значения, или, другими словами, преобразовать опционал в соответствующий ему базовый тип. 

Выделяют три способа извлечения опционального значения:

- принудительное извлечение;
- косвенное извлечение;
- операция объединения с nil (рассматривается в конце главы). 
- После извлечения значение опционального типа приводится к базовому, а значит, может взаимодействовать с другими значениями базового типа. 

### Принудительное извлечение значения – forced unwrapping

```swift
var result: Int? = 30
print(result) // будет предупреждение 
// Консоль: Options(30) 
```

wrap – заворачивать, unwrap – разворачивать

Преобразует значение опционального типа в значение базового (например, Int? в Int) с помощью знака восклицания ` ! `, указываемого после имени параметра с опциональным значением. 

```swift
var optVar: Int? = 12
var intVar = 34
let result = optVar! + 34     // 46
// проверяем тип данных извлеченного значения
type(of: optVar!) // Int.Type
```

Константа optVar — это опционал. Для проведения арифметической операции с целочисленным значением используется принудительное извлечение ` ! `. `#exclamation mark` после имени переменной сообщает компилятору, что вы хотите заглянуть внутрь box и извлечь значение. Таким образом, операция сложения производится между двумя неопциональными целочисленными значениями. 

Такой же подход используется и при работе с типами, отличными от Int 

```swift
let optString: String? = "Vasiliy Usov"
let unwrapperString = optString!
print("My name is \(unwrapperString)")  // My name is Vasiliy Usov
```

Отсутствие значения в опционале приведет к ошибке

Вы можете использовать оператор `if`, чтобы узнать, содержит ли optional параметр значение, сравнив optional параметр с `nil`.

```swift
if convertedNumber != nil { 
    print("convertedNumber contains some integer value.") 
} 
```

Убедившись, что `optional` параметр действительно содержит значение, вы можете получить доступ к его базовому значению, добавив восклицательный знак ( `!` ) В конце имени optional элемента.

Восклицательный знак говорит: «Я знаю, что этот optional параметр определенно имеет значение; пожалуйста, используйте это." Это называется принудительным разворачиванием (forced #unwrapping) значения optional  параметра:

```swift
if convertedNumber != nil { 
    print("convertedNumber has an integer value of \(convertedNumber!).") 
} else { print("no number") }
// Prints "convertedNumber has an integer value of 123."
```

### Косвенное извлечение значения – implicitly unwrapping. Implicitly Unwrapped Optionals – Неявно развернутые опционалы

`#Implicitly Unwrapped Optionals`. Если вы уверены, что в момент проведения операции с опционалом в нем всегда будет значение (**не nil**), то **при явном указании типа данных знак вопроса может быть заменен на знак восклицания.** При этом все последующие обращения к параметру необходимо производить без принудительного извлечения, так как оно будет происходить автоматически 

```swift
var wrapInt: Double! = 3.14
// сложение со значением базового типа не вызовет ошибок
// при этом не требуется использовать принудительное извлечение
wrapInt + 0.12 // 3.26
```

Как описано выше, optionals параметры указывают, что constant or variable разрешено «не иметь значения». Optionals параметры можно проверить с помощью оператора if, чтобы узнать, существует ли значение, и можно условно unwrapped размернуть с помощью optionals привязки для доступа к значению optionals элемента, если оно существует.

Иногда из структуры программы ясно, что optionals параметр всегда будет иметь значение после того, как это значение будет установлено впервые. В этих случаях полезно избавиться от необходимости проверять и разворачивать значение optionals элемента каждый раз, когда к нему обращаются, поскольку можно с уверенностью предположить, что оно все время имеет значение. 

Эти виды опций определяются как неявно развернутые опциональные опции – **implicitly unwrapped optionals**. Вы пишете implicitly unwrapped optionals, помещая восклицательный знак `(String!)`, а не вопросительный знак `(String?)`. После типа, который вы хотите сделать optionals. Вместо того, чтобы помещать восклицательный знак после имени optionals элемента, когда вы его используете, вы помещаете восклицательный знак после типа optionals при его объявлении.

An implicitly unwrapped неявно развернутые optional параметры полезны, когда подтверждается существование значения optional параметра сразу после того, как оно было впервые определено, и можно определенно предположить, что оно существует в любой момент после этого. 

Неявно развернутый optional параметр – это обычный optional параметр за кулисами, но его также можно использовать как optional значение, без необходимости развертывать optional значение при каждом обращении к нему. В следующем примере показано различие в поведении optional строки и неявно развернутой optional строки при доступе к их обернутому wrapped значению как явной строке:

```swift
let possibleString: String? = "An optional string." 
let forcedString: String = possibleString! // нужен ! 
let assumedString: String! = "An implicitly unwrapped optional string." 
let implicitString: String = assumedString // не нужен !
```

Вы можете думать о неявно развернутом optional (implicitly unwrapped optional) элементе как о разрешении для optional элемента принудительно развернуть его, если это необходимо. Когда вы используете неявно развернутое optional значение, Swift сначала пытается использовать его как обычное optional значение; если его нельзя использовать как optional, Swift принудительно разворачивает значение. В приведенном выше коде optional значение assumedString принудительно разворачивается перед присвоением его значения implicitString, поскольку implicitString имеет явный, optional тип String. В приведенном ниже коде optionalString не указан явный тип, поэтому он является обычным optional.

```swift
let optionalString = assumedString 
// The type of optionalString is "String?" and assumedString isn't force-unwrapped. 
```

Если implicitly unwrapped optional равен `nil` и вы пытаетесь получить доступ к его обернутому (wrapped) значению, вы вызовете ошибку выполнения. Результат будет таким же, как если бы вы поместили восклицательный знак после обычного optional параметра, не содержащего значения. Вы можете проверить, является ли implicitly unwrapped optional параметр `nil` так же, как вы проверяете обычный optional параметр:

```swift
if assumedString != nil { 
    print(assumedString!)
}
// Prints "An implicitly unwrapped optional string."
```

You can also use an implicitly unwrapped optional with `optional #binding` (доп. привязка), to check and unwrap its value:

```swift
if let definiteString = assumedString { 
    print(definiteString)
}
// Prints "An implicitly unwrapped optional string." 
```

Не используйте implicitly unwrapped optional (неявно развернутый optional параметр), если есть вероятность того, что переменная позже станет нулем. Всегда используйте обычный optional тип, если вам нужно проверить нулевое значение в течение времени существования переменной.

### Проверка наличия значения в опционале 

Для осуществления проверки наличия значения в опционале его можно сравнить с nil. При этом будет возвращено логическое true или false в зависимости от наличия значения 

```swift
let optOne: UInt? = nil
let optTwo: UInt? = 32
optOne != nil // false
optTwo != nil // true
// or
optOne == nil // true
optTwo == nil // false
```

Подобное выражение можно использовать совместно с оператором условия if. Если в опционале имеется значение, то в теле оператора оно может быть извлечено без ошибок. 

Пример, в котором определяется количество положительных оценок, а точнее пятерок. Если пятерки есть, то вычисляется количество пирожных, которые необходимо приобрести в награду за старания. 

```swift
var fiveMarkCount: Int? = 8
var allCakesCount = 0;
// определение наличия значения
if fiveMarkCount != nil {
    // количество пирожных за каждую пятерку
    let cakeForEachFiveMark = 2
    // общее количество пирожных
    allCakesCount = cakeForEachFiveMark * fiveMarkCount!
}
allCakesCount // 16
```

Обратите внимание на то, что при вычислении значения `allCakesCount` в теле конструкции if используется принудительное извлечение опционального значения переменной fiveMarkCount. 

Данный способ проверки существования значения опционала работает исключительно при принудительном извлечении опционального значения, так как косвенно извлекаемое значение не может быть равно `nil`, а значит, и сравнивать его с `nil` не имеет смысла. 

### Опциональное связывание `if let связываемый_параметр = опционал{ }` Optional Binding (привязка, связка)

В ходе проверки наличия значения в опционале существует возможность одновременного извлечения значения (если оно не nil) и инициализации его во временный параметр. Этот способ носит название **опционального связывания (optional binding)** и является наиболее корректным способом работы с опционалами. 

```swift
  if let связываемый_параметр = опционал {
    // тело оператора
  }
```

В результате опционального связывания создается связанный параметр, в который при возможности извлекается значение опционала. Если опционал не равен `nil`, то будет выполнен код в теле оператора, в котором значение опционала будет доступно через связанный параметр. 

```swift
if let userName = userLogin {
  print("Имя: \(userName)")
} else { 
  print("Имя не введено")
}
// userLogin - опционал
type(of: userLogin) // Optional<String>.Type
```

Swift includes a feature known as optional binding, which lets you safely access the value inside an optional. Optional #Binding #привязка #связывание безопасная альтернатива вышеописанному принудительному извлечению (**If Statements and Forced Unwrapping** )

Вы используете optional привязку, чтобы узнать, содержит ли optional параметр значение, и если да, то сделать это значение доступным как временную константу или переменную. Optional привязка может использоваться с операторами `if` и `while` для проверки значения внутри `optional` и для извлечения этого значения в constant or variable как часть одного действия.

```swift
if let constantName = someOptional { 
    // statements 
}
```

Если possibleNumber может быть приведено в Int, то выполнится if, если нет, будет содержать string, к примеру, то выполнится else

```swift
let possibleNumber = "123"
if let actualNumber = Int(possibleNumber) {
    print("The string \"\(possibleNumber)\" has an integer value of \(actualNumber)")
} else {
    print("The string \"\(possibleNumber)\" couldn't be converted to an integer")
}
```

Этот код можно прочитать как: «Если optional Int, возвращаемый Int (possibleNumber), содержит значение, установите новую константу с именем actualNumber равной значению, содержащемуся в optional». Если преобразование прошло успешно, константа actualNumber становится доступной для использования в первой ветви оператора if. Он уже инициализирован значением, содержащимся в необязательном поле, поэтому вы не используете **!** суффикс для доступа к его значению. В этом примере actualNumber просто используется для печати результата преобразования. Вы можете использовать как let, так и var с optional привязкой. Если вы хотите манипулировать значением actualNumber в первой ветви оператора if, вы можете вместо этого написать if var actualNumber, и значение, содержащееся в optional элементе, будет доступно как переменная, а не как константа.

Вы можете включить столько optional привязок и логических условий в один оператор if, сколько вам нужно, **разделив их запятыми**. Если какое-либо из значений в optional привязках равно нулю или какое-либо логическое условие оценивается как ложное, все условие оператора if считается ложным. Следующие операторы if эквивалентны:

```swift
if let firstNumber = Int("4"), **let** secondNumber = Int("42"), firstNumber < secondNumber && secondNumber < 100 {
    print("\(firstNumber) < \(secondNumber) < 100")
}
// Prints "4 < 42 < 100"

if let firstNumber = Int("4") {
    if let secondNumber = Int("42") {
        if firstNumber < secondNumber && secondNumber < 100 {
        print("\(firstNumber) < \(secondNumber) < 100")
        }
    }
}
// Prints "4 < 42 < 100"
```

**Константы и переменные, созданные с optional привязкой в операторе if, доступны только в теле оператора if**. Напротив, константы и переменные, созданные с помощью оператора `guard`, доступны в строках кода, следующих за оператором защиты, как описано в разделе «Early exit».


Напомню, что область видимости определяет, где в коде доступен некоторый объект. Если этот объект является глобальным, то он доступен в любой точке программы (его область видимости не ограничена). Если объект является локальным, то он доступен только в том блоке кода (и во всех вложенных в него блоках), для которого является локальным. Вне этого блока объект просто не виден. 

```swift
let markCount: Int? = 8
// определение наличия значения
if let marks = markCount {
    print("Всего \(marks) оценок")
}
// Консоль: Всего 8 оценок
```

Так как опционал markCount не nil, в ходе опционального связывания происходит автоматическое извлечение его значения с последующей инициализацией в локальную константу marks. 

Переменная, создаваемая при опциональном связывании, локальна для оператора условия, поэтому использовать ее можно только внутри данного оператора. Если бы в переменной markCount не существовало значения, то тело оператора условия было бы проигнорировано. Вы можете не ограничиваться одним опциональным связыванием в рамках одного оператора if 

```swift
var pointX: Int? = 10
var pointY: Int? = 3
if let x = pointX, let y = pointY 
    print("Точка установлена на плоскости")
}
// Консоль: Точка установлена на плоскости
```

В этом примере проверяется наличие значений в обеих переменных. Если бы хоть одна из переменных соответствовала nil, то вывод на консоль оказался бы пуст. 

Xcode уведомляет о том, что объявленные в ходе опционального связывания **константы не используются в теле оператора, вследствие чего они могут быть заменены нижним подчеркиванием  `_`** 

Ранее мы уже неоднократно встречались с **нижним подчеркиванием**, позволяющим игнорировать определенные элементы или значения. Напомню, **что оно может заменять имена параметров в тех случаях, когда в их объявлении нет необходимости**. В данном примере опциональное связывание требуется лишь с целью определения наличия значений в опционалах, при этом внутри блока кода оператора условия созданные параметры не используются. Поэтому можно последовать совету среды разработки и заменить имена констант на нижнее подчеркивание. 

<img alt="image" src="images/нижним подчеркиванием _ .jpg"/>


```swift
if let _ = pointX, let _ = pointY {
    print("Точка установлена на плоскости")
}
if let x = pointX, x > 5 {
    print("Точка очень далеко от вас ")
}
// Консоль: Точка очень далеко от вас
```

Или же, можно использовать в качестве привязки **тоже самое имя** опционала, чтобы  не мучаться с придумыванием имени локальной переменной

```swift
if let authorName = authorName {
    print("Author is \(authorName)")
} else {
    print("No author.")
}

// or with two
if let authorName = authorName, let authorAge = authorAge {
    print("The author is \(authorName) who is \(authorAge) years old.")
} else {
    print("No author or no age.")
}
```

You can combine unwrapping multiple optionals with additional Boolean checks

The expression in the if statement will only be true if name is non-nil, and age is non-nil, and age is greater than or equal to 40.

```swift
if let authorName = authorName,
    let authorAge = authorAge, authorAge >= 40 {
    print("The author is \(authorName) who is \(authorAge) years old.")
} else {
    print("No author or no age or age less than 40.")
}
```

### Опциональное связывание как часть оптимизации кода

Представьте, что у вас есть группа драконов, у большинства из которых есть свой сундук с золотом, а количество золотых монет в каждом из этих сундуков разное. В любой момент времени может потребоваться знать общее количество монет во всех сундуках. Внезапно к вам поступает новый дракон, его золото тоже должно быть учтено. 

Напишем код, в котором определяется количество монет в сундуке нового дракона (если, у него есть сундук), после чего оно суммируется с общим количеством золота 

```swift
/* переменная типа String, содержащая количество золотых монет в сундуке нового дракона */
var coinsInNewChest = "140"

/* переменная типа Int, в которой будет храниться общее количество монет у всех драконов */
var allCoinsCount = 1301

// проверяем существование значения
if Int(coinsInNewChest) != nil {
    allCoinsCount += Int(coinsInNewChest)!
} else {
    print("У нового дракона отсутствует золото")
}
```

У вас мог возникнуть вопрос, почему в качестве количества монет в сундуке не используется значение целочисленного типа.

- в интерфейсе мнимой программы, вполне вероятно, будет находиться текстовое поле, в котором будет вводиться строковое значение, содержащее количество монет; 

- монеты могут отсутствовать по причине отсутствия сундука, а 0 в качестве значения говорит о том, что сундук есть, но монет в нем нет. 

На первый взгляд все очень просто и логично, и в результате значение переменной allCoinsCount станет равно 1441. Но обратите внимание, что Int(coinsInNewChest) используется дважды: 

- при сравнении с nil; 

- при сложении с переменной allCoinsCount. 

В результате происходит бесцельная трата процессорного времени, так как одна и та же функция выполняется дважды. Можно избежать такой ситуации, заранее создав переменную `coins`, в которую будет извлечено значение опционала. Данную переменную необходимо использовать в обоих случаях `вместо` вызова функции `Int(_:)` 

```swift
let coinsInNewChest = "140"
var allCoinsCount = 1301
/* извлекаем значение опционала в новую переменную */
var coins = Int(coinsInNewChest)
//проверяем существов значения с использованием созданной переменной
if coins != nil {
    allCoinsCount += coins!
} else {
    print("У нового дракона отсутствует золото")
}
```

Код решает поставленную задачу, но у него есть один недостаток: созданная переменная `coins` будет существовать (и занимать оперативную память) даже после завершения работы условного оператора, хотя в ней нет необходимости. Необходимо всеми способами избегать бесполезного расходования ресурсов компьютера, к которым относится и процессорное время, и оперативная память. 

Чтобы избежать расходования памяти, **можно использовать опциональное связывание**, так как после выполнения оператора условия созданная при связывании переменная автоматически удалится 

```swift
let coinsInNewChest = "140"
var allCoinsCount = 1301
// проверяем существов значения с использованием опциональн связывания
if let coins = Int(coinsInNewChest) {
    allCoinsCount += coins
} else { 
    print("У нового дракона отсутствует золото")
}
```

### Оператор объединения с nil (nil coalescing)

Nil Coalescing Operator – Оператор нулевого слияния

С помощью оператора `??` (называемого оператором объединения с nil) возвращается либо значение опционала, либо значение по умолчанию (если опционал равен nil). 

`let имя_параметра = имя_опционала ?? значение_по_умолчанию`

`имя_параметра: T` — имя нового параметра, в который будет извлекаться значение опционала. 

`имя_опционала: Optional<T>` — имя параметра опционального типа, из которого извлекается значение. 

`значение_по-умолчанию: T` — значение, инициализируемое новому параметру в случае, если опционал равен `nil`. 

Если опционал не равен nil, то опциональное значение извлекается и инициализируется в объявленный параметр. 
Если опционал равен nil, то в параметре инициализируется значение, расположенное справа от оператора `??`. Для навигации( #?? ) #nil #coalescing.

Базовый тип опционала и тип значения по умолчанию должны быть одним и тем же типом данных. 
Вместо оператора let может быть использован оператор var.

`let optionalInt: Int? = 20`

`var mustHaveResult = optionalInt ?? 0  // 20`

Таким образом, константе mustHaveResult будет проинициализировано целочисленное значение. Так как в optionalInt есть значение, оно будет извлечено и присвоено константе mustHaveResult. Если бы optionalInt был равен nil, то mustHaveResult принял бы значение 0. 

```swift
let optionalInt: Int? = 20
var mustHaveResult: Int
if let unwrapped = optionalInt {
    mustHaveResult = unwrapped
} else {
    mustHaveResult = 0
}
```

**Наиболее безопасными способами извлечения значений из опционалов являются опциональное связывание и nil coalescing**. Старайтесь использовать именно их в своих приложениях. 

The nil-coalescing operator (a ?? b) unwraps разворачивает an optional если он содержит значение, или возвращает значение по умолчанию b, если a равно nil. Выражение a всегда of an optional type. Выражение b должно соответствовать типу, хранящемуся внутри a. Оператор nil-coalescing является сокращением для приведенного ниже кода:

`a != nil ? a! : b`

В приведенном выше коде используется тернарный условный оператор и принудительное развертывание (forced unwrapping) (`a!`) Для доступа к значению, заключенному внутри `a`, когда `a` не равно nil, и для возврата `b` в противном случае. Оператор nil-coalescing предоставляет более элегантный способ инкапсулировать эту условную проверку и разворачивание в сжатой и удобочитаемой форме. 

ПРИМЕЧАНИЕ. Если значение `a` не равно нулю, значение `b` не оценивается. Это известно как оценка короткого замыкания. В примере ниже оператор nil-coalescing используется для выбора между именем цвета по умолчанию и optional пользовательским именем цвета:

```swift
let defaultColorName = "red" 
var userDefinedColorName: String? // defaults to nil 
var colorNameToUse = userDefinedColorName ?? defaultColorName 
// userDefinedColorName is nil, so colorNameToUse is set to the default of "red"
```

Переменная userDefinedColorName определяется как необязательная строка со значением по умолчанию `nil`. Поскольку userDefinedColorName имеет необязательный тип, вы можете использовать оператор nil-coalescing, чтобы рассмотреть его значение. В приведенном выше примере оператор используется для определения начального значения для строковой переменной с именем colorNameToUse. Поскольку userDefinedColorName имеет значение nil, выражение userDefinedColorName ?? defaultColorName возвращает значение defaultColorName или «красный». Если вы присваиваете userDefinedColorName значение, отличное от nil, и снова выполняете проверку оператора nil-coalescing, вместо значения по умолчанию используется значение, заключенное внутри userDefinedColorName:

```swift
userDefinedColorName = "green" 
colorNameToUse = userDefinedColorName ?? defaultColorName // userDefinedColorName isn't nil, so colorNameToUse is set to "green"
```

### Краткое содержание главы Опционалы 

Используется, когда параметр может иметь некоторое значение или не иметь его вовсе. 

Загрузка записи из базы данных по его ID может либо вернуть эту запись, либо вернуть `nil`, указывающий на то, что такой записи нет в базе.

```swift
   func getObjectBy(id: UInt) -> Object? {
       // код загрузки данных из базы
   }
```

Получение файла по его имени. При отсутствии файла с таким именем возвращается nil. 

```swift
   func getFileBy(name: UInt) -> File? {
       // код загрузки файла
   }
```

Ресурс большого объема, который в будущем заменится на nil, чтобы освободить память. 

Указатель на наличие/отсутствие ошибки в результате запроса на сервер. 

```swift
   let error: Error? = getErrorFromServerQuery()
   guard let error = error else {
       print("Ошибок нет")
   }
   print("Ошибка \(error.code)")
```

Оператор `guard` - если условие true, то код выполняется дальше, если условие false то переходим к else

Свойства класса, которые будут установлены уже после его инициализации. К примеру, свойства класса ViewController будут связаны с элементами на сцене (IBOutlet) уже после того, как произойдет инициализация. 

```swift
class ViewController: UIViewController {
    var textArea: UITextArea!
    var button: UIButton!
    // ...
} 
```

**Challenges**

**Challenge 2: Divide and conquer**

First, create a function that returns the number of times an integer can be divided by another integer without a remainder. The function should return nil if the division doesn’t produce a whole number. Name the function divideIfWhole.
Then, write code that tries to unwrap the optional result of the function. There should be two cases: upon success, print "Yep, it divides \(answer) times", and upon failure, print "Not divisible :[".

Finally, test your function:
Divide 10 by 2. This should print "Yep, it divides 5 times."
Divide 10 by 3. This should print "Not divisible :[."

Hint 1: Use the following as the start of the function signature:
You’ll need to add the return type, which will be an optional!

Hint 2: You can use the modulo operator (%) to determine if a value is divisible by another; recall that this operation returns the remainder from the division of two numbers. 10 % 2 = 0 means that 10 is divisible by 2 with no remainder, whereas 10 % 3 = 1 means that 10 is divisible by 3 with a remainder of 1.

```swift
func divideIfWhole(_ value: Int, by divisor: Int) -> Int? {
    if value % divisor == 0 {
        return value / divisor
    } else {
        return nil
    }
}

if let answer = divideIfWhole(10, by: 2) {
    print("Yep, it divides \(answer) times.")
} else {
    print("Not divisible :[.")
}
// Yep, it divides 5 times.

if let answer = divideIfWhole(10, by: 3) {
    print("Yep, it divides \(answer) times.")
} else {
    print("Not divisible :[.")
}
// Not divisible :[.
```

**Challenge 3: Refactor and reduce**

The code you wrote in the last challenge used if statements. In this challenge, refactor that code to use nil coalescing instead. This time, make it print "It divides X times" in all cases, but if the division doesn’t result in a whole number, then X should be 0.

```swift
let answer1 = divideIfWhole(10, by: 2) ?? 0
print("It divides \(answer1) times.")

let answer2 = divideIfWhole(10, by: 3) ?? 0
print("It divides \(answer2) times.")
```

**Challenge 4: Nested optionals**

Consider the following #nested optional. It corresponds to a number inside a box inside a box inside a box.

```swift
let number: Int??? = 10
If you print number you get the following:
print(number)
// Optional(Optional(Optional(10)))
print(number!)
// Optional(Optional(10))
```

1. Fully force unwrap and print number.
2. Optionally bind and print number with if let.
3. Write a function printNumber(_ number: Int???) that uses guard to print the number only if it is bound.

```swift
let number: Int??? = 10
// 1
print(number!!!)

// 2
if let number = number {
  if let number = number {
    if let number = number {
      print(number)
    }
  }
}

// Better way of optionally binding without all the {}
if let n1 = number,
   let n2 = n1,
   let n3 = n2 {
  print(n3)
}

// 3
func printNumber(_ number: Int???) {
  guard let n1 = number, let n2 = n1, let n3 = n2 else {
    return
  }
  print(n3)
}
printNumber(number)
```

---

[К оглавлению](#contents)

###  <a id="chapter12" /> Глава №12. Функции

Функция объединяет строки кода в один блок, который можно использовать снова. Некоторые функции имеют входные данные и изменяют свое поведение на основе аргументов вызывающего объекта, некоторые функции имеют выходные данные и дают результат, а некоторые функции не имеют ни того, ни другого.

**Свойство** – это часть данных, хранящихся в структуре, классе или перечислении. Например, каждый экземпляр массива имеет свойство `count`, которое отличается в зависимости от характеристик массива.

Parameters – If the function has parameters (inputs), если функция имеет параметры (входы), они перечислены с именем, используемым для доступа к параметру, и краткое описание параметра

Функция:

- группирует программный код в единый контейнер; 
- имеет собственное имя, с помощью которого может быть многократно вызвана с возможностью передачи аргументов;
- создает отдельную область видимости внутри себя, в результате чего все созданные в теле функции параметры недоступны извне; 
- может принимать входные параметры; 
- может возвращать значение как результат исполнения сгруппированного в ней кода; 
- имеет собственный функциональный тип данных; 
- может быть записана в параметр (переменную или константу) и в таком виде передана. 

«Функцию стоит объявлять тогда, когда некоторый программный код может быть многократно использован. С ее помощью исключается дублирование кода, так как она позволяет не писать его дважды». 

Готовая функция — это черный ящик, у которого скрыта внутренняя реализация. Вам важно лишь то, для чего она предназначена, что принимает на вход и что возвращает. 

Рассмотрим пример. В качестве функции может выступать соковыжималка. Вы, ничего не знаете о ее внутреннем устройстве, но обладаете информацией о ее предназначении (выжимать сок), входных аргументах (свежие фрукты и овощи) и возвращаемом значении (свежевыжатый сок). 

```swift
func имяФункции (входные_параметры) -> ТипВозвращаемогоЗначения {
       // тело функции
   }
```

`имяФункции` — имя объявляемой функции, по которому она сможет быть вызвана. К функциям применимы те же правила именования, что и к параметрам. 

`входные_параметры` — список входных параметров функции с указанием их имен и типов. 

`ТипВозвращаемогоЗначения` — тип данных значения, возвращаемого функцией. Если функция ничего не возвращает, то данный элемент может быть опущен. 

Объявление функции начинается с ключевого слова `func`. Далее имя создаваемой функции. Оно используетс при каждом ее вызове в вашем коде

     `func myFirstFunc`

Далее в скобках указываются входные параметры функции. Список параметров заключается в круглые скобки и состоит из разделенных запятыми элементов. Каждый отдельный элемент описывает один параметр и состоит из имени и типа этого параметра, разделенных двоеточием. Параметры позволяют передать в функцию значения, которые ей требуются для корректного выполнения возложенных на нее задач. Количество параметров может быть произвольным (также они могут вовсе отсутствовать). 

```swift
func myFirstFunc(
     a: Int,
     b: String)
```

Указанные параметры являются локальными для функции, таким образом, `a` и `b` будут существовать только в пределах ее тела. По окончании ее работы данные параметры будут уничтожены и станут недоступными. 

```swift
func triple(value: Int) {
    let result = value * 3
    print(”If you multiply \(value) by 3, you’ll get \(result).”)
}
```

Внимание!!! При объявлении функции в скобках указываются **входные параметры**, а при вызове функции передаются **аргументы**.

```swift
     // входные параметры a и b
     func myFirstFunc(a: Int, b: String) { ... }
     // аргументы a и b
     myFirstFunc(a: 54, b: "слово")
```

**Вам необходимо запомнить, что при вызове функции указываются аргументы, а внутри функции используются параметры**

Далее, после списка параметров, может быть указан тип возвращаемого значения. Для этого используется стрелка `->`, после которой следует имя конкретного типа данных. В качестве типа можно задать любой фундаментальный тип, тип массива или кортежа, или любой другой. 

```swift
     func myFirstFunc(
            a: Int,
            b: String
     ) -> String
```

или 

```swift
func myFirstFunc(
       a: Int,
       b: String
) -> [(String,Int)?]
```

Если функция **не должна возвращать никакого значения**, то на это можно указать тремя способами: 
с помощью ключевого слова `#Void` (это Good Practice), например: 

```swift
     func myFirstFunc(
     a: Int,
     b: String
     ) -> Void
```

с помощью пустых скобок `( )`, например: 

```swift
     func myFirstFunc(
     a: Int,
     b: String
     ) -> ()
```

не указывать тип вовсе   , например: 

```swift
     func myFirstFunc(
     a: Int,
     b: String)
```

Если функция возвращает какое-либо значение, то в ее теле должен присутствовать оператор `#return`, за которым следует возвращаемое значение. После выполнения программой оператора `return` работа функции завершается и происходит выход из нее.

```swift
     func myFirstFunc(
         a: Int,
         b: String
     ) -> String {
         let word = "Swift"
         return String(a) + b + word
     }
```

В данном случае тело функции состоит всего из одного выражения, в котором содержится оператор return. После его выполнения функция вернет сформированное значение и завершит свою работу. 
При этом если тело функции состоит из одного выражения single statement, значение которого должно быть возвращено, то оператор `return` может быть опущен. 

```swift
     func myFirstFunc(
         a: Int,
         b: String
     ) -> String {
         String(a) + b
     }
```

Процесс обращения к объявленной функции по ее имени называется вызовом функции.
Функция может содержать произвольное количество операторов `return`. При достижении первого из них будет произведено завершение ее работы. 

Предположим, что вам требуется многократно выводить на консоль один и тот же текст. Для реализации этого можно объявить новую функцию, которая при обращении к ней будет производить необходимую операцию 

```swift
func printMessage() {
    print("Сообщение принято")
}
// вызываем функцию по ее имени
printMessage()
printMessage()
```

Вывод информации на консоль с помощью `print(_:)` не является возвращаемым функцией значением. **Возвращаемое значение может быть проинициализировано параметру.**

### Входные параметры и возвращаемое значение 

Функция может принимать входные параметры в качестве входных значений и возвращать результат своей работы (возвращаемое значение). И для входных, и для возвращаемого значений должны быть определены типы данных. 

```swift
func sumTwoInt(a: Int, b: Int) {
    print("Результат операции - \(a+b)")
}
sumTwoInt(a: 10, b: 12) // Результат операции – 22
```

Функция `sumTwoInt(a:b:)` имеет два входных параметра типа Int — `a` и `b`. 

Внешние External и внутренние internal имена входных параметров. Argument labels 

Swift позволяет указать **внешние имена** ( `#argument label` ) параметров, которые будут использоваться при вызове функции. Они добавляют читаемости и ясности.

```swift
func sayHello(to person: String, and anotherPerson: String) {
    print(”Hello \(person) and \(anotherPerson)”)
}
sayHello(to: “Miles”, and: “Riley”)
```

`#External` внешние and `#internal` внутренние names come from in the function declaration

```swift
func printMultipleOf(multiplier: Int, and value: Int) {
  print("\(multiplier) * \(value) = \(multiplier * value)")
}
printMultipleOf(multiplier: 4, and: 2)


func sumTwoInt(num1 a: Int, num2 b: Int) {
    print("Результат операции - \(a+b)")
}
sumTwoInt(num1: 10, num2: 12)
```

Если внешнее имя заменить на символ нижнего подчеркивания ( ` _ ` ), то при вызове функции имя параметра вообще не потребуется указывать. Это вариант не использовать внешнее имя или argument label. 

```swift
func sumTwoInt(_ a: Int, _ b: Int) {
    print("Результат операции - \(a+b)")
}
sumTwoInt(10, 12)
```

### Возвращаемое значение 

Доработаем функцию `sumTwoInt(_: _: )` таким образом, чтобы она не только выводила сообщение на консоль, но и возвращала результат сложения. Для этого необходимо выполнить два требования: 

- должен быть указан тип возвращаемого значения; 
- должен быть использован оператор return в теле функции с возвращаемым значением в качестве операнда. 

```swift
func sumTwoInt(_ a: Int, _ b: Int) -> Int {
    let result = a + b
    print("Результат операции - \(result)")
    return result
}
```

or 

```swift
func sumTwoInt(_ a: Int, _ b: Int) -> Int {         return a + b 
}
```

or

```swift
func sumTwoInt(_ a: Int, _ b: Int) -> Int { 
    a + b 
}

var result = sumTwoInt(10, 12) // 22
// Консоль: Результат операции – 22
// or
print("Результат операции - \(result)")
print("Результат операции - \( sumTwoInt(10, 12))")
```

Обратите особое внимание на то, что в теле функции объявляется константа result, а после функции — переменная с таким же именем. Это два различных и независимых параметра! Все, что объявляется в теле функции, является локальным для нее и уничтожается после завершения ее работы. Таким образом, в теле константа используется для вывода информации на консоль и совместно с оператором return, а вне функции в новую и другую переменную result записывается возвращенное функцией значение. 

### Изменяемые копии входных параметров 

Все входные параметры функции — константы. При попытке изменения их значения внутри тела функции происходит ошибка. 
Важно отметить, что Swift копирует значение перед передачей его в функцию – поведение, известное как передача по значению `pass-by-value`. При необходимости изменения переданного входного значения внутри функции потребуется создать новую переменную и присвоить переданное значение ей 

```swift
func returnMessage(code: Int, message: String) -> String {
    var mutableMessage = message
// преобразование code: Int в String
    mutableMessage += String(code) 
    return mutableMessage
}
let myMessage = returnMessage(code: 200, message: "Код сообщения - ")
```

Функция `returnMessage(code:message:)` получает на вход два аргумента: code и message. В ее теле создается изменяемая копия message, которая без каких-либо ошибок модифицируется, после чего возвращается. 

### Сквозные параметры 

Приведенный способ модификации значений параметров позволяет получать доступ к изменяемому значению только в пределах тела самой функции. Для того чтобы была возможность модификации параметров с сохранением измененных значений после окончания работы функции, необходимо использовать #сквозные параметры. 

Иногда вы хотите, чтобы функция изменяла параметр напрямую, поведение, известное как `copy-in` `copy-out` or `call by value result`.
Чтобы преобразовать входной параметр в сквозной, перед описанием его типа необходимо указать модификатор `#inout`. 

Inout до того, как тип параметра будет указан, что этот параметр должен быть скопирован, и эта локальная копия используется в функции, и должна быть скопировала обратно, когда функция return

Сквозной параметр передается в функцию, изменяется в ней и сохраняет свое значение при завершении работы функции, заменяя собой исходное значение. При вызове функции перед передаваемым значением аргумента необходимо ставить символ `#амперсанд #ampersand  (&)`, указывающий на то, что параметр передается по ссылке. 
В примере, функция осуществляет обмен значениями двух внешних параметров (меняет их местами)

```swift
func changeValues(_ a: inout Int, _ b: inout Int) -> Void {
    let tmp = a
    a = b 
    b = tmp 
} 
var x = 150, y = 45
print(x) // 150
print(y) // 45
changeValues(&x, &y)
print(x) // 45
print(y) // 150
```

Функция принимает на входе две переменные, a и b. Эти переменные передаются в функцию как сквозные параметры, что позволяет изменить их значения внутри функции и сохранить эти изменения после завершения ее работы. 
В качестве сквозного параметра может выступать только переменная. Константы или литералы нельзя передавать, так как они являются неизменяемыми. 

### Функция в качестве входного параметра 

Вы можете использовать возвращаемое некоторой функцией значение в качестве значения входного параметра другой функции. Самое важное, чтобы тип возвращаемого значения функции совпадал с типом входного параметра. 
Ниже объявленная ранее функция `returnMessage (code: message: )`, возвращающая значение типа String. 

```swift
// используем функцию в качестве значения
print( returnMessage(code: 400, message: "Сервер недоступен. Код сообщения - ") ) 
// Консоль: Сервер недоступен. Код сообщения – 400
```

Уже известная нам функция `print(_:)` принимает на входе строковый литерал типа String. Так как функция `returnMessage(code: message: )` возвращает значение этого типа, она может быть указана в качестве входного параметра для `print(_:)`. 

### Входной параметр с переменным числом значений. Вариативный тип 

В некоторых ситуациях необходимо, чтобы функция получала неизвестное заранее число однотипных значений. Мы уже встречались с таким подходом при использовании `Array(arrayLiteral: )`, когда заранее неизвестно, сколько элементов будет содержать параметр arrayLiteral. Такой тип входного параметра называется вариативным. 

#Вариативный параметр обозначается в списке входящих параметров с указанием оператора диапазона `...` сразу после типа. Значения аргумента при вызове функции задаются через запятую. 

Представьте, что удаленный сервер на каждый запрос отправляет вам несколько ответов. Каждый ответ — это целое число, но их количество может быть различным. Вам необходимо написать функцию, которая принимает на входе все полученные ответы и выводит их на консоль. 

```swift
func printRequestString(codes: Int...) -> Void {
    var codesString = ""
    for oneCode in codes {
        codesString += String(oneCode) + " "
    }
    print("Получены ответы — \(codesString)")
}
printRequestString(codes: 600, 800, 301) // Получены ответы — 600 800 301
printRequestString(codes: 101, 200) // Получены ответы — 101 200
```

Параметр codes может содержать произвольное количество значений указанного типа. Внутри функции он трактуется как последовательность (Sequence), поэтому его можно обработать с помощью конструкции `for-in`. 
У одной функции может быть только один вариативный параметр, и он должен находиться в самом конце списка входных параметров. 

### Кортеж tuple в качестве возвращаемого значения 

Функция может возвращать значения любого типа данных. Отдельно отмечу, что и кортежи могут быть использованы для этого, так как с их помощью можно с легкостью вернуть сразу несколько значений (возможно, именно этого вам не хватало в других языках программирования). 
Представленная ниже функция принимает на вход код ответа сервера и в зависимости от того, к какому диапазону относится переданный код, возвращает кортеж `#tuplefunc` с его описанием. 

```swift
func getCodeDescription(code: Int) -> (Int, String) {
    let description: String
    switch code {
    case 1...100:
        description = "Error"
    case 101...200:
        description = "Correct"
    default:
        description = "Unknown"
    }
    return (code, description)
}
getCodeDescription(code: 150) // (150, "Correct")
```

В качестве типа возвращаемого значения функции `getCodeDescription(code: )` указан тип кортежа, содержащего два значения: код и его описание. 

Функцию `getCodeDescription(code:)` можно улучшить, если указать не просто тип возвращаемого кортежа, а названия его элементов (прямо в типе возвращаемого функцией значения) 

```swift
func getCodeDescription(code: Int) -> (code: Int, description: String) {
    let description: String
    switch code {
    case 1...100:
        description = "Error"
    case 101...200:
        description = "Correct"
    default:
        description = "Unknown"
    }
    return (code, description)
}
let request = getCodeDescription(code: 45)
request.description  // "Error"
request.code  // 45
```

Полученное в ходе работы `getCodeDescription(code:)` значение записывается в константу `request`, у которой появляются свойства `description` и `code`, что соответствует именам элементов возвращаемого кортежа. 

```swift
func multiplyAndDivide(_ number: Int, by factor: Int) -> (product: Int, quotient: Int) {
  return (number * factor, number / factor)
}
let results = multiplyAndDivide(4, by: 2)
let product = results.product     //8
let quotient = results.quotient   //2
```

### Значение по умолчанию для входного параметра 

Напомню, что все входные параметры должны обязательно иметь значения. Ранее для этого мы указывали их при вызове функции. Но существует возможность определить значения по умолчанию, которые позволяют не указывать значения при вызове. 

Другими словами, если вы передали значение входного параметра, то оно будет использовано в теле функции; если вы не передали значение параметра, для него будет использовано значение по умолчанию. Значение по умолчанию указывается при объявлении функции в списке входных параметров для каждого параметра отдельно. 
Доработаем объявленную ранее функцию `returnMessage(code: message: )` таким образом, чтобы была возможность не передавать значение параметра `message`. Для этого укажем значение по умолчанию 

```swift
func returnMessage(code: Int, message: String = "Код - ") -> String {
    var mutableMessage = message
    mutableMessage += String(code)
    return mutableMessage
}
returnMessage(code: 300) //"Код - 300"
```

Как вы можете видеть, при вызове `returnMessage(code: message: )` не передается значение для параметра message. Это стало возможным благодаря установке значения по умолчанию "Код - " в списке входных параметров. 
Тело функции `returnMessage(code: message: )` может состоять из одного выражения, и следовательно лишиться оператора return. 

```swift
func returnMessage(code: Int, message: String = "Код - ") -> String {
    message + String(code)
}
returnMessage(code: 300) // "Код - 300"
```

**Функция, которая принимает не более одного параметра, — это замечательно. 
Функции с двумя или тремя параметрами — у вас должны быть серьезные причины для того, чтобы реализовать ее. 
Функция с четырьмя и более параметрами — отличный повод пересмотреть структуру вашего кода. 
Каждая функция, которую вы реализуете, должна выполнять четкую и конкретную задачу. Не стоит создавать функции-комбайны, которые выполняют несколько задач сразу.**

### Функциональный тип 

Одно из свойств функции заключается в том, что она может быть записана в параметр и с его помощью передана. Но как такое возможно, если у любого параметра, как мы знаем, должен быть определенный тип данных? Любая **функция имеет свой функциональный тип данных**, который указывает на типы входных и выходного значений. 

### Простой функциональный тип 

Если функция ничего не принимает и не возвращает, то ее тип указывается круглой скобкой и ключевым словом `#Void` после стрелки: 

`() -> Void`

Также возможен вариант с двумя парами круглых скобок, разделенных стрелкой `() -> ()`, но он не является хорошей практикой программирования. 
Ниже приведен пример функции с типом `() -> Void`, то есть не имеющей ни входных, ни выходных параметров. 

```swift
func printErrorMessage() {
    print("Произошла ошибка")
}
```

В первых скобках функционального типа всегда описываются типы данных входных параметров, а после стрелки указывается тип данных выходного значения (если, конечно, оно существует). Если функция принимает на вход массив целочисленных значений, а возвращает опциональное строковое значение, то ее тип данных будет выглядеть следующим образом: 

`([Int]) -> String?`

Обратите внимание, что при наличии возвращаемого значения оно указывается вместо круглых скобок, а не в них. 
В левой части функционального типа указываются типы входных параметров, в правой — тип выходного значения.

```swift
var steps = 0
func incrementSteps() {
    steps += 1
    print(steps)
}
incrementSteps()
```

### Сложный функциональный тип 

В некоторых случаях выходное значение функции также является функцией, которая, в свою очередь, может возвращать значение. В результате этого функциональный тип становится сложным, то есть содержащим несколько указателей на возвращаемое значение (несколько стрелок ` -> `). 

В самом простом варианте функция, возвращающая другую функцию, которая ничего не возвращает, будет иметь такой функциональный тип: 

`() -> () -> Void`

Представим, что некоторая функция принимает на вход значение типа `Int` и возвращает функцию, которая принимает на вход значение типа String и возвращает значение типа Bool. Ее функциональный тип будет выглядеть следующим образом: 

`(Int) -> (String) -> Bool`

Каждый блок, описывающий типы данных входных параметров, заключается в круглые скобки. Так можно определить, где начинается функциональный тип очередной функции. 

Но функция может не только возвращаться другой функцией, но и передаваться в качестве входного параметра. Далее функция принимает на вход целое число и другую функцию, а возвращает логическое значение. 

`(Int, (Int) -> Void) -> Bool`

Функция, которая передается в качестве входного параметра, имеет тип `(Int) -> Void`, то есть она сама принимает целочисленное значение, но не возвращает ничего. 

### Function is known to never return

Некоторые функции никогда не ничего не возвращают. Например, подумайте о функции, которая предназначена для сбоя приложения. Что если приложение собирается работать с неизвестными/подозрительными данными. Функция `fatalError("reason to terminate")` является примером такой функции. Он печатает причину фатальной ошибки, а затем останавливает выполнение для предотвращения дальнейшего повреждения приложения. После изучения `UIApplicationMain or NSApplicationMain` вернуться к этой теме.

```swift
func noReturn() -> Never {

}
```

Notice the special return type `#Never`, indicating that this function will never return.
If you wrote this code you would get the following error:
Function with uninhabited return type 'Never' is missing call to another never-returning function on all paths

```swift
func infiniteLoop() -> Never {
    while true {
    }
}
```

Вы можете задаться вопросом, зачем этот специальный тип возврата. Это полезно из-за компилятора, зная, что функция никогда не вернется, она может сделать определенные оптимизации при создании кода для вызова функции. По сути, код, который вызывает функцию, не должен выполнять что-либо после вызова функции, потому что он знает, что эта функция никогда не закончится до того, как приложение будет прекращено.

### Commenting your functions

В Swift есть очень простой способ документирования функций. Стандарт комментариев `#Doxygen`, используемый многими другими языками за пределами Swift. 

```swift
func calculateAverage(of a: Double, and b: Double, and c: Double) -> Double {
    let total = a + b + c
    let average = total / 3
    return average
}
calculateAverage(of: 1, and: 3, and: 5)
```

Вы используете тройной `///`. 

Первая строка – это описание того, что делает функция. 

Далее следует список параметров 

Описание возвращаемого значения

Вызвать шаблон `Option-Command-/`

<img alt="image" src="images/Commenting your functions.jpg"/>

При вызове функции xcode, будет подсказывать

<img alt="image" src="images/Commenting your functions1.jpg"/>

### Функция в качестве входного и возвращаемого значений 

### Возвращаемое значение функционального типа

Так как функция имеет определенный функциональный тип, его можно использовать для того, чтобы указать возвращаемое функцией значение. Так, функция может вернуть другую функцию. 

Ниже объявлена функция `returnPrintTextFunction()`, которая возвращает значение функционального типа `() -> Void`, то есть другую функцию. 

```swift
// функция вывода текста на консоль
func printText() {
    print("Функция вызвана")
}
// функция, которая возвращает функцию
func returnPrintTextFunction() -> () -> Void {
    return printText
}
print("шаг 1")
let newFunctionInLet = returnPrintTextFunction()
print("шаг 2")  
newFunctionInLet() 
print("шаг 3") 
```

Для возвращения функции другой функцией достаточно **указать ее имя (без скобок)** после оператора `return`. Тип возвращаемого значения `returnPrintTextFunction()` соответствует собственному типу `printText()`. 
В результате инициализации значения константе newFunctionInLet ее тип данных неявно определяется как `() -> Void`, а сама она хранит в себе функцию, которую можно вызывать, указав имя хранилища с круглыми скобками после него. 

Так как строка Функция вызвана находится между шагами 2 и 3, а не между 1 и 2, можно сделать вывод о том, что функция вызывается не в ходе инициализации значения константе `newFunctionInLet`, а именно в результате выражения `newFunctionInLet()`. 

### Входное значение функционального типа 

Функции в SWIFT – это просто другой тип данных. Вы можете назначить их переменным или константам так же, как любой другой тип значения

```swift
func add(_ a: Int, _ b: Int) -> Int {
    a + b
}
var function = add // function type (Int, Int) -> Int
function(4, 2) //6
```

Вы можете установить переменную функции из предыдущего значения в новую функцию вычитания, потому что список параметров и тип возвращаемого значения вычитания совместимы с типом переменной функции.

```swift
func subtract(_ a: Int, _ b: Int) -> Int {
  a - b
}
function = subtract
function(4, 2) //2
```

Как уже говорилось, функции могут выступать в качестве входных параметров. Переданную таким образом функцию можно будет использовать в теле той функции, в которую она была передана. Для этого необходимо указать корректный функциональный тип входного параметра и в качестве его значения указать имя передаваемой функции. 

```swift
func printResult(_ function: (Int, Int) -> Int, _ a: Int, _ b: Int) {
    let result = function(a, b)
    print(result)
}
printResult(add, 4, 2) // 6
printResult(subtract, 4, 2) //2
```

`printResult` takes three parameters:

1. function is of a function type that takes two Int parameters and returns an Int, declared like so: (Int, Int) -> Int.
2. a is of type Int.
3. b is of type Int.

Напишем функцию `generateWallet(walletLength: )`, случайным образом генерирующую массив банкнот, каждая из которых представлена целым числом разрешенного номинала. Функция должна принимать на вход требуемое количество банкнот в кошельке. 

Также реализуем функцию с именем `sumWallet`, которая может принять на вход `generateWallet(walletLength: )`, после чего вычисляет и возвращает сумму всех банкнот в кошельке 

```swift
// функция генерации случайного массива банкнот
func generateWallet(walletLength: Int) -> [Int] {
    // существующие типы банкнот
    let typesOfBanknotes = [50, 100, 500, 1000, 5000]
    // массив банкнот
    var wallet: [Int] = []
    // цикл генерации массива случайных банкнот
    for _ in 1...walletLength {
    wallet.append(typesOfBanknotes.randomElement()! )
    }
    return wallet
}

// функция подсчета денег в кошельке
func sumWallet(
    banknotesFunction wallet: (Int) -> [Int],
    walletLength: Int
) -> Int? {
    // вызов переданной функции
    let myWalletArray = wallet(walletLength)
    var sum: Int = 0
        for oneBanknote in myWalletArray {
            sum += oneBanknote
    }
    return sum 
} 
// передача функции в функцию
sumWallet(banknotesFunction: generateWallet, walletLength: 20) // 6900
```

Значение в области результатов, будет отличаться, это связано с использованием метода `#randomElement()`, который возвращает случайный элемент коллекции `typesOfBanknotes`. 

Функция `generateWallet(walletLength: )` создает массив банкнот такой длины, которая передана ей в качестве входного параметра. В массиве `typesOfBanknotes` содержатся все доступные (разрешенные) номиналы банкнот. Суть работы функции такова: банкнота случайным образом изымается из массива `typesOfBanknotes`, после чего помещается в массив-кошелек `wallet`, который является возвращаемым значением. Обратите внимание, что в цикле `for` вместо переменной используется символ нижнего подчеркивания. В данном случае он заменяет собой создаваемый в цикле параметр, так как внутри цикла он не используется. 

В качестве типа входного параметра `banknotesFunction` функции `sumWallet(banknotesFunction: walletLength: )` указан функциональный тип `(Int) -> [Int]`. Он соответствует типу функции `generateWallet(walletLength: )`
. 
При вызове `sumWallet(banknotesFunction: walletLength: )` необходимо указать лишь имя передаваемой функции без фигурных скобок. 

Чего мы добились таким образом? Того, что функция `sumWallet(banknotesFunction: walletLength: )` может принять на вход не только `generateWallet(walletLength:)`, но и любую другую функцию с соответствующим типом. К примеру, можно реализовать функцию `get1000wallet(walletLength: )`, возвращающую массив указанной длины из тысячных банкнот, после чего передать ее в качестве аргумента в 
`sumWallet(banknotesFunction: walletLength: )`

### Параметры функционального типа для ленивых вычислений 

**Ленивые вычисления позволяют получить некоторое значение не в момент передачи параметра, а при попытке доступа к хранящемуся в нем значению.** 

У вас есть две функции, каждая из которых предназначена для вычисления некоторой математической величины. Обе функции являются ресурсозатратными, то есть при работе занимают продолжительное процессорное время и значительный объем памяти. Первая из них высчитывает указанный знак после запятой в числе `π`, а вторая — первую цифру числа с указанным порядковым номером в последовательности Фибоначчи. Помимо этого, существует третья функция, которая принимает на вход оба числа и в зависимости от внутренней логики использует только одно из переданных значений. 

В самом общем виде вы могли бы использовать функции примерно следующим образом: 

```swift
// порядковый номер числа, которое нужно получить
let n = 1000000
// передаем значения в главную функцию
returnSomeNum(getPiNum(n),getFibNum(n))
```

Функция `returnSomeNum(_: _: )` имеет функциональный тип `(Int, Int) -> Int`. В ней два входных целочисленных параметра, но внутри своей реализации она использует только один из них (об этом сказано в условии выше); получается, что ресурсы, использованные на получение второго числа, потрачены впустую. Но мы вынуждены делать это, так как невозможно заранее сказать, какое из чисел будет использовано. 
Выходом из этой ситуации может стать применение входных параметров с функциональным типом. То есть если преобразовать функцию `returnSomeNum(_: _: )` к типу `((Int) -> Int, (Int) -> Int) -> Int`, то в нее можно передать не результаты работы функций `getPiNum(_: )` и `getFibNum(_: )`, а сами функции. Далее в ее теле будет применена именно та функция, которая требуется, а ресурсы на подсчет второй использоваться не будут. То есть необходимое значение будет получено именно в тот момент, когда к нему произойдет обращение, а не в тот момент, когда функции переданы в виде аргумента.

### Возможности функций. Вложенные функции 

Функции могут входить в состав друг друга, то есть они могут быть вложенными. **Вложенные функции обладают ограниченной областью видимости, то есть напрямую доступны только в теле родительской функции.** 
Представьте бесконечную плоскость и точку на этой плоскости. Точка имеет некоторые координаты. Она может перемещаться по плоскости. Создадим функцию, которая принимает на входе координаты точки и направление перемещения, после чего передвигает точку и фиксирует ее новые координаты

```swift
func oneStep(
    coordinates: inout (Int, Int),
    stepType: String
) -> Void {
    func up( coords: inout (Int, Int)) {
        coords = (coords.0+1, coords.1)
    }
    func right( coords: inout (Int, Int)) {
        coords = (coords.0, coords.1+1)
    }
    func down( coords: inout (Int, Int)) {
        coords = (coords.0-1, coords.1)
    }
    func left( coords: inout (Int, Int)) {
        coords = (coords.0, coords.1-1)
    }
    switch stepType {
    case "up":
        up(coords: &coordinates)
    case "right":
        right(coords: &coordinates)
    case "down":
        down(coords: &coordinates)
    case "left":
        left(coords: &coordinates)
    default: break 
    } 
}
var coordinates = (10, -5)
oneStep(coordinates: &coordinates, stepType: "up")
oneStep(coordinates: &coordinates, stepType: "right")
coordinates // (.0 11, .1 -4)
```

Функция `oneStep(coordinates: stepType: )` осуществляет перемещение точки по плоскости. В ней определено несколько вложенных функций, которые вызываются в зависимости от значения параметра `stepType`. Данный набор функций доступен только внутри родительской функции `oneStep(coordinates: stepType: )`

Входной параметр `coordinates` является сквозным, поэтому все изменения, производимые в нем, сохраняются и после окончания работы функции. 

### Перегрузка функций - Overloading

#Overloading. То есть в одной и той же области видимости создавать функции с одинаковыми именами. Различия функций должны заключаться в их функциональных типах (входных и выходных параметрах), внешних именах, типы и число параметров, возвращаемое значение. 
Пример разных функций с одним именем

```swift
func printMultipleOf(multiplier: Int, andValue: Int)
func printMultipleOf(multiplier: Int, and value: Int)
func printMultipleOf(_ multiplier: Int, and value: Int)
func printMultipleOf(_ multiplier: Int, _ value: Int)
```

Ниже представлены функции, которые могут сосуществовать одновременно в одной области видимости. 

```swift
func say(what: String) -> Void { }
func say(what: Int) -> Void { }
```

У данных функций одно и то же имя `say(what: )`, один и тот же тип возвращаемого значения, но различные типы входных параметров. В результате Swift определяет обе функции как различные и позволяет им сосуществовать одновременно. Это связано с тем, что функциональный тип первой функции `(String) -> Void`, а второй `(Int) -> Void`. 

Представленные ниже функции могут сосуществовать одновременно. Влияет также возвращаемое значение

```swift
func cry() -> String {
    return "one"
}
func cry() -> Int {
    return 1 
} 
```

В данном случае можно сделать важное замечание: возвращаемое значение функции не может быть передано переменной или константе без явного указания типа объявляемого параметра 

`let resultOfFunc = say() // ошибка`

В данном случае Swift просто не знает, какой тип данных у константы, поэтому не может определить, какую функцию вызвать. В результате Xcode сообщит об ошибке. 
Если каким-либо образом указать тип данных параметра, согласуемый с типом возвращаемого значения одной из функций, то код отработает корректно 

```swift
let resultString: String = cry() // "one"
let resultInt = cry() + 100 // 101
```

### Рекурсивный вызов функций 

Функция может вызывать саму себя. Этот механизм называется `#рекурсией`. Очень многие алгоритмы могут быть реализованы с помощью данной техники. Однако, по невнимательности можно создать «бесконечную петлю», в которой функция будет постоянно вызывать саму себя. При корректном использовании рекурсий функция всегда будет завершать свою работу. 

```swift
func countdown(firstNum num: Int) -> Void {
    print(num)
    if num > 0 {
        // рекурсивный вызов функции
        countdown(firstNum:num-1)
    }
}
countdown(firstNum: 20)
```

Функция `countdown(firstNum:)` делает обратный отчет, начиная от переданного параметра `firstNum` и заканчивая нулем. Этот алгоритм реализуется рекурсивным вызовом функции. 
**Функции – используются, когда необходимо сгруппировать блок кода для его многократного использования.**

**Challenges**

2.It’s prime time
Determine – дитёйман, определять, устанавливать
Divisible – делить, разделить 
Divisor – делитель 

func `isNumberDivisible` определяет делится ли число без остатка на делитель. func `isPrime` определяет простое ли число или нет

Hint 1: Numbers less than 0 should not be considered prime. Check for this case at the start of the function and return early if the number is less than 0.
Hint 2: Use a for loop to find divisors. Если вы начнете с двух и заканчите самим числом, то как только вы найдете делитель, вы можете false.
Hint 3: you can simply loop from 2 until you reach the square root of number, rather than going all the way up to number itself.

```swift
func isNumberDivisible(_ number: Int, by divisor: Int) -> Bool {
  number % divisor == 0
}

func isPrime(_ number: Int) -> Bool {
  if number < 0 {
    return false
  }
  /* We handle these cases up front because we want to make sure the range 2...root (used below) is valid, which is the case only when root >= 2, so for numbers >= 4  */
  if number <= 3 {
    return true
  }

  let doubleNumber = Double(number)
  let root = Int(doubleNumber.squareRoot())
  for divisor in 2...root {
    if isNumberDivisible(number, by: divisor) {
      return false
    }
  }
  return true
}
isPrime(6)
isPrime(13)
isPrime(8893)

// Корень вычисляет только с типом числа Double
let name: Double = 64
let root = name.squareRoot() // 8
```

3. Recursive functions
    Функция, которая вычисляет значение из последовательности Фибоначчи. Любое значение в последовательности – это сумма двух предыдущих значений. Последовательность определена так, что первые два значения равны 1. То есть `fibonacci(1) = 1 и fibonacci(2) = 1`.

- для значений числа меньше 0 вы должны вернуть 0.
- чтобы начать последовательность, жестко запрограммируйте возвращаемое значение 1, когда число равно 1 или 2. Для любого другого значения вам нужно будет вернуть сумму вызовов фибоначчи с числом 1 и числом 2

```swift
func fibonacci(_ number: Int) -> Int {
    if number <= 0 { return 0 }
    if number == 1 || number == 2 { return 1 }
    return fibonacci(number - 1) + fibonacci(number - 2)
}
fibonacci(1)      // 1
fibonacci(2)      // 1
fibonacci(3)      // 2
fibonacci(4)      // 3
fibonacci(5)      // 5
fibonacci(10)    // 55
```

**Apple. Challenges**

1. 

```swift
let goal = 10000
var steps = 1000
func progressUpdate() {
    let percent = Double(steps)/Double(goal)
    if percent < 0.1 {
        print("You're off to a good start.")
    } else if percent < 0.5 {
        print("You're almost halfway there!")
    } else if percent < 0.9 {
        print("You're over halfway there!")
    } else if steps < goal {
        print("You're almost there!")
    } else {
        print("You beat your goal!")
    }
}
progressUpdate()

// or
func progressUpdate(steps: Int, goal: Int) {
    let percent = Double(steps)/Double(goal)
    if percent < 0.1 {
        print("You're off to a good start.")
    } else if percent < 0.5 {
        print("You're almost halfway there!")
    } else if percent < 0.9 {
        print("You're over halfway there!")
    } else if steps < goal {
        print("You're almost there!")
    } else {
        print("You beat your goal!")
    }
}
progressUpdate(steps: 5013, goal: 10000) // You're over halfway there!
```

2. Your fitness tracking app is going to help runners stay on pace to reach their goals. Write a function called pacing that takes four Double parameters called currentDistance, totalDistance, currentTime, and goalTime. Your function should calculate whether or not the user is on pace to hit or beat goalTime. If yes, print "Keep it up!", otherwise print "You've got to push it just a bit harder!"

```swift
func pacing(currentDistance: Double, totalDistance: Double, currentTime: Double, goalTime: Double) {
    let pace = currentTime/(currentDistance/totalDistance)
    if pace < goalTime {
        print("Keep it up!")
    } else {
        print("You've got to push it just a bit harder!")
    }
}
pacing(currentDistance: 100, totalDistance: 200, currentTime: 6.0, goalTime: 10.0)
```

3. Разделим функцию выше (2), которая выполняет 2 действия на две функции и тем самым оптимизируем ее на будущее. Функция всегда должна выполнять одну задачу
    As an example, write a function that only does a portion of what your previous pacing function did. This function will be called calculatePace. It should take three Double arguments called currentDistance, totalDistance, and currentTime, and should return a Double that will represent the time at which the user will finish the run based on the user's current distance and time. call the function and print the return value.

```swift
func calculatePace(currentDistance: Double, totalDistance: Double, currentTime: Double) -> Double {
    return currentTime/(currentDistance/totalDistance)
}

let pace = calculatePace(currentDistance: 50, totalDistance: 100, currentTime: 4.8)
print(pace)
```

Later. Now write a function called pacing that takes four Double arguments called currentDistance, totalDistance, currentTime, and goalTime. The function should also return a String, which will be the message to show the user. The function should call calculatePace, passing in the appropriate values, and capture the return value. The function should then compare the returned value to goalTime and if the user is on pace return "Keep it up!", and return "You've got to push it just a bit harder!" otherwise. Call the function and print the return value.

```swift
func pacing(currentDistance: Double, totalDistance: Double, currentTime: Double, goalTime: Double) -> String {
    let pace = calculatePace(currentDistance: currentDistance, totalDistance: totalDistance, currentTime: currentTime)
    if pace <= goalTime {
        return "Keep it up!"
    } else {
        return "You've got to push it just a bit harder!"
    }
}
let motivation = pacing(currentDistance: 50, totalDistance: 100, currentTime: 4.8, goalTime: 10)
print(motivation)
```

---

[К оглавлению]()

### <a id="chapter13" />  Глава №13. Замыкания (closure) 

#Замыкания (closures) — это организованные блоки с определенной функциональностью, которые могут быть переданы и использованы в коде. 

Замыкания #closure, или замыкающие выражения, — это сгруппированный программный код, который может быть передан в виде параметра и многократно использован. Ничего не напоминает? Если вы скажете, что в этом определении узнали функции, то будете полностью правы. 

### Виды замыканий 

Как вы знаете, параметры предназначены для хранения информации, а функции могут выполнять определенные задачи. Говоря простым языком, **с помощью замыканий вы можете поместить блок исполняемого кода в переменную или константу, свободно передавать ее и при необходимости вызывать хранящийся в ней код**. Вы уже видели подобный подход при изучении функций. Дело в том, что **функции — это частный случай замыканий**. 

В общем случае замыкание (closure) может принять две формы: 

- именованная функция;
- безымянная функция, определенная с помощью облегченного синтаксиса. 

Далее **#безымянные функции будут именоваться замыканиями**, или замыкающими выражениями. Говоря о функции, мы будем иметь в виду именно функции, а говоря о **замыканиях — безымянные функции**. 

### Введение в безымянные функции (замыкания) 

Как вы уже знаете, переменная и константа может хранить в себе ссылку на функцию. Но для того, чтобы организовать это, не обязательно возвращать одну функцию из другой. Вы можете использовать специальный облегченный синтаксис, создав безымянную функцию, после чего передать ее в качестве значения в требуемый параметр. Безымянные функции не имеют имен. Они состоят только из тела, заключенного в фигурные скобки. 

```swift
   { (входные_параметры) -> ТипВозвращаемогоЗначения in
       // тело замыкающего выражения
   }
```

`входные_параметры` — список аргументов замыкания с указанием их имен и типов. 

`ТипВозвращаемогоЗначения` — тип данных значения, возвращаемого замыканием.

Замыкающее выражение пишется в фигурных скобках. После указания перечня входных аргументов и типа возвращаемого значения ставится ключевое слово `in`, после которого следует тело замыкания. 

В самом простом случае можно опустить указание входных параметров и тип выходного значения, оставив лишь тело замыкания. 

```swift
// безымянная функция в качестве значения константы
let functionInLet = { return true }
// вызываем безымянную функцию
functionInLet() // true
```

Константа `functionInLet` имеет функциональный тип `() -> Bool` (ничего не принимает на вход, но возвращает логическое значение) и хранит в себе тело функции. 
Обратите внимание, что при инициализации безымянной функции в параметр для ее вызова используется имя параметра с круглыми скобками. 

В нашей программе объявлена переменная `wallet`, хранящая в себе программный аналог кошелька с купюрами (в пред. главе мы уже использовали массив-кошелек). Каждый элемент этой коллекции представляет собой одну банкноту опред. номинала. Перед нами стоит задача отбора банкнот в кошельке по различным условиям. Для каждого условия может быть создана отдельная функция, принимающая на вход массив wallet и возвращающая отфильтрованную коллекцию. 

```swift
// массив с купюрами
var wallet = [10,50,100,100,5000,100,50,50,500,100]
// функция отбора купюр
func handle100(wallet: [Int]) -> [Int] {
    var returnWallet = [Int]()
    for banknote in wallet {
        if banknote == 100 {
            returnWallet.append(banknote)
        }
    } 
    return returnWallet
}
// вызов функции отбора купюр с достоинством 100
handle100(wallet: wallet) // [100, 100, 100, 100]
```

При каждом вызове функция `handle100(wallet: )` будет возвращать массив сторублевых купюр переданного массива-кошелька. 
Но условия отбора не ограничиваются данной функцией. Расширим функционал нашей программы, написав дополнительную функцию для отбора купюр достоинством 1000 рублей и более 

```swift
func handleMore1000(wallet: [Int]) -> [Int] {
    var returnWallet = [Int]()
    for banknote in wallet {
        if banknote >= 1000 {
            returnWallet.append(banknote)
        }
} 
    return returnWallet
}
// вызов функции отбора купюр с достоинством более или равно 1000
handleMore1000(wallet: wallet) // [5000]
```

В результате для отбора купюр по требуемым условиям реализовано уже две функции: `handle100(wallet: )` и `handleMore1000(wallet: )`. При этом тела обеих функций очень похожи, разница лишь в проверяемом условии, остальной код в функциях один и тот же. 
Для решения проблемы дублирования можно пойти двумя путями: 

- реализовать всю функциональность отбора купюр в пределах одной функции, а в качестве аргумента передавать условие; 
- реализовать всю функциональность в виде трех функций. Первая будет группировать повторяющийся код и принимать в виде аргумента одну из двух других функций. Переданная функция будет производить проверку условия в теле главной функции.

Если выбрать первый путь, то при увеличении количества условий отбора единая функция будет разрастаться и в конце концов станет нечитабельной и слишком сложной. Плюс к этому необходимо придумать, каким образом передавать указатель на проверяемое условие, а значит, потребуется вести документацию к данной функции. 

По этой причине воспользуемся вторым вариантом, реализуем функционал в виде трех функций: 

- Функция с именем `handle`, принимающая массив-кошелек и условие отбора (в виде имени функции) в качестве аргументов и возвращающая массив отобранных купюр. В теле функции будут поочередно проверяться элементы входного массива на соответствие переданному условию. 

- Функция с именем `compare100`, принимающая на вход значение очередного элемента массива-кошелька, производящая сравнение с целым числом 100 и возвращающая логический результат этой проверки. 

- Функция с именем `compareMore1000`, аналогичная `compare100`, но производящая проверку на соответствие целому числу 1000. 

```swift
// единая функция формирования результирующего массива
func handle(wallet: [Int], closure: (Int) -> Bool) -> [Int] {
    var returnWallet = [Int]()
    for banknote in wallet {
        if closure(banknote) {
            returnWallet.append(banknote)
        }
    } 
    return returnWallet
}
// функция сравнения с числом 100
func compare100(banknote: Int) -> Bool {
    return banknote == 100
}
// функция сравнения с числом 1000
func compareMore1000(banknote:Int) -> Bool {
    return banknote >= 1000
}
// отбор
let resultWalletOne = handle(wallet: wallet, closure: compare100)
let resultWalletTwo = handle(wallet: wallet, closure: compareMore1000)
```

Функция `handle(wallet:closure: )` получает в качестве входного параметра `closure` одну из функций проверки условия и в операторе `if` вызывает переданную функцию. Функции проверки принимают на вход анализируемую купюру и возвращают `Bool` в зависимости от результата сравнения. Чтобы получить купюры определенного достоинства, необходимо вызвать функцию `handle(wallet: closure: )` и передать в нее имя одной из функций проверки. 

Представим, что возникла необходимость написать функции для отбора купюр по многим и многим условиям, найти все полтинники; все купюры достоинством менее 1000 рублей; все купюры, которые без остатка делятся на 200, и т. д. В определенный момент писать отдельную функцию проверки для каждого из них станет довольно тяжелой задачей, так как для того, чтобы использовать единую функцию проверки, необходимо знать имя проверяющей функции, а их могут быть десятки. 
В подобной ситуации можно отказаться от создания отдельных функций и передавать в `handle(wallet: closure: )` условие отбора в виде безымянной функции. 

```swift
// отбор купюр достоинством выше 1000 рублей
// аналог передачи compareMore1000
handle(wallet: wallet, closure: { (banknote: Int) -> Bool in
    return banknote >= 1000
})
// отбор купюр достоинством 100 рублей
// аналог передачи compare100
handle(wallet: wallet, closure: { (banknote: Int) -> Bool in
    return banknote == 100
})
```

Входной параметр `closure` имеет функциональный тип `(Int)->Bool`, а значит, передаваемая безымянная функция должна иметь тот же тип данных, что мы видим в коде. 

Для переданного замыкания указан входной параметр типа `Int` и определен тип возвращаемого значения `(Bool)`. После ключевого слова `in` следует тело функции, в котором с помощью оператора `return` возвращается логическое значение – результат проверки очередного элемента кошелька. Таким образом, в теле функции `handle(wallet: closure: )` будет вызываться не какая-то внешняя функция, имя которой передано, а безымянная функция, переданная в виде входного параметра. 

В результате такого подхода необходимость в существовании функций `compare100(banknote: )` и `compareMore1000(banknote: )` отпадает, так как код условия передается напрямую в качестве замыкания в аргумент `closure`. 

### Возможности замыканий. Пропуск указания типов 

При объявлении входного параметра `closure` в функции `handle(wallet: closure: )` указывается его функциональный тип `(Int)->Bool`, поэтому при передаче замыкающего выражения можно опустить данную информацию, оставив лишь имя аргумента 

```swift
// отбор купюр достоинством выше 1000 рублей
handle(wallet: wallet, closure: { banknote in
    return banknote >= 1000
})
```

В замыкающем выражении перед ключевым словом `in` необходимо указать только имя параметра без входных и выходных типов. 

### Неявное возвращение значения 

Если тело замыкающего выражения содержит всего одно выражение, которое возвращает некоторое значение (с использованием оператора `return`), то такие замыкания могут неявно возвращать выходное значение. «Неявно» — значит, без использования оператора `return`

`handle(wallet: wallet, closure: { banknote in banknote >= 1000})`

### Сокращенные имена параметров `$номер_параметра`

В случае, когда замыкание состоит из одного выражения, можно опустить указание входных параметров (все до ключевого слова `in`, включая само слово). При этом доступ к входным параметрам внутри тела замыкания необходимо осуществлять через сокращенные имена в форме `$номер_параметра`. Номера входных параметров начинаются с нуля. (Знак `#$`)

В сокращенной форме записи имен входных параметров обозначение `$0` указывает на первый передаваемый аргумент. 

Для доступа ко второму аргументу необходимо использовать обозначение `$1`, к третьему — `$2` и т. д. 
Перепишем вызов функции `handle(wallet: closure: )` с использованием сокращенных имен 

`handle(wallet: wallet, closure: {$0>=1000})`

Здесь `$0` — это входной параметр `banknote` аргумента closure в функции `handle(wallet: closure: )`. 
Было изначально так :

```swift
handle(wallet: wallet, closure: { (banknote: Int) -> Bool in
    return banknote >= 1000
})
```

### Вынос замыкания за скобки 

Если входной параметр функции расположен последним в списке входных параметров функции (как в данном случае в функции `handle(wallet: closure: )`, где параметр closure является последним), Swift позволяет вынести его значение (тело замыкающего выражения) за круглые скобки 

`handle(wallet: wallet){ $0 >= 1000 }`

Эта возможность особенно полезна, когда замыкание, передаваемое в качестве аргумента функции, является многострочным. Пример выноса замыкания, состоящего из нескольких выражений. С его помощью производится сравнение элементов с массивом «разрешенных» купюр. В результирующей коллекции будут находиться только те купюры, которые являются «разрешенными». 

```swift
handle(wallet: wallet) { banknote in
    for number in Array(arrayLiteral: 100,500) {
        if number == banknote {
            return true 
       } 
  } 
      return false
  }
```

Существует и другой способ реализовать проверку из предыдущего листинга. Для этого можно использовать метод `contains(_: )`, передавая в него очередную купюру: 

```swift
var wallet = [10,50,100,100,5000,100,50,50,500,100]
let successBanknotes = handle(wallet: wallet) { [100,500].contains($0) }
successBanknotes // [100, 100, 100, 500, 100]
```

### Вынос нескольких замыканий за скобки

Начиная с версии 5.3, в Swift появилась возможность вынести за скобки не одно, а все замыкания, находящиеся в конце списка аргументов. Предположим, что вы написали функцию, осуществляющую запрос на сервер.

```swift
func networkQuery(url: String, success: (String) -> (), error: (Int) -> ()) {
    // код запроса на сервер
}
```

В качестве аргументов в функцию передаются URL-адрес и два замыкания: первое будет вызвано в случае успешного окончания запроса, а второе — в случае ошибки. При вызове функции `networkQuery` вы можете использовать как стандартный синтаксис, указывая замыкания прямо в списке аргументов, так и упрощенный, вынеся оба замыкания за скобки 

```swift
// классический вариант
networkQuery(url: "https://weather.com", success: { data in }, error: {errorCode in })

// новый вариант
networkQuery(url: "https://weather.com") { data in
    // ...
} error: { errorCode in
// ... } 
```

Данная возможность будет использоваться вами очень часто при работе с фреймворком `SwiftUI`. 

### Безымянные функции в параметрах () -> Void 

Пример инициализации замыкания в параметр `closure`. При этом у параметра явно указан функциональный тип (ранее в примерах он определялся неявно). 

```swift
let closure: () -> Void = {
    print("Замыкающее выражение")
}
closure() 
// Консоль: Замыкающее выражение
```

Так как данное замыкающее выражение не имеет входных параметров и возвращаемого значения, то его тип равен `() -> Void`. Для вызова, записанного в константу замыкающего выражения, необходимо написать имя константы с круглыми скобками, точно так же, как мы делали это ранее. 

Явное указание функционального типа позволяет определить входные параметры и тип выходного значения 

```swift
// передача в функцию строкового значения
let closurePrint: (String) -> Void = { text in
    print(text)
}
closurePrint("Text")
// Консоль: Text 

// передача в функцию целочисленных значений
// с осуществлением доступа через краткий синтаксис $0 и $1
var sum: (_ numOne: Int, _ numTwo: Int) -> Int = { $0 + $1 } 
sum(10, 34) // 44
```

Ключевое слово `return` не используется в замыкании sum, так как его тело состоит из одного выражения. 

### Пример использования замыканий при сортировке массива 

Одним из таких методов является `#sorted(by: )`, предназначенный для сортировки массивов, как строковых, так и числовых. Он принимает на входе массив, который необходимо отсортировать, и условие сортировки. 

Принимаемое условие сортировки — это обыкновенное замыкающее выражение, которое вызывается внутри метода `sorted(by: )`, принимает на входе два очередных элемента сортируемого массива и возвращает значение Bool в зависимости от результата их сравнения. 
Ниже массив `array` сортируется таким образом, чтобы элементы были расположены по возрастанию. Для этого в метод `sorted(by: )` передается замыкающее выражение, которое возвращает true, когда второе из сравниваемых чисел больше. 

```swift
let array = [1,44,81,4,277,50,101,51,8]
var sortedArray = array.sorted(by: { (first: Int, second: Int) -> Bool in
    return first < second
})
sortedArray // [1, 4, 8, 44, 50, 51, 81, 101, 277]
```

Теперь применим все рассмотренные ранее способы оптимизации замыкающих выражений:

- уберем функциональный тип замыкания;
- уберем оператор return;
- заменим имена переменных именами сокращенной формой. 

В результате получится выражение ниже. Как и в предыдущем примере, здесь тоже необходимо отсортировать массив `array` таким образом, чтобы элементы были расположены по возрастанию. Для этого в метод `sorted(by:)` передается такое замыкающее выражение, которое возвращает true, когда второе из сравниваемых чисел больше. Сокращенный вариант

```swift
let array = [1,44,81,4,277,50,101,51,8]
var sortedArray = array.sorted(by: { $0 < $1 })
sortedArray // [1, 4, 8, 44, 50, 51, 81, 101, 277]
```

В результате код получается более читабельным и красивым. 
Супер сокращенный вариант. Но и это еще не все. Так как выражение в замыкании состоит всего из одного бинарного оператора, то можно убрать даже имена параметров, оставив лишь оператор сравнения 

```swift
let array = [1,44,81,4,277,50,101,51,8]
var sortedArray = array.sorted(by: <)
sortedArray // [1, 4, 8, 44, 50, 51, 81, 101, 277]
```

### Захват переменных. Синтаксис захвата переменных 

Существуют два параметра, `a` и `b`, которые не передаются в качестве аргументов в замыкание, но используются им в вычислениях. При каждом вызове такого замыкания оно будет определять значения данных параметров, прежде чем приступить к выполнению операции с их участием. 

```swift
var a = 1
var b = 2
let closureSum: () -> Int = { a + b }
closureSum() // 3 
a = 3
b = 4 
closureSum() // 7 
```

Замыкание, хранящееся в константе `closureSum`, складывает значения переменных `a` и `b`. При изменении их значений возвращаемое замыканием значение меняется. 
Существует способ **«захватить»** значения параметров, то есть зафиксировать те значения, которые имеют эти параметры на момент объявления замыкающего выражения. Для этого в начале замыкания в квадратных скобках необходимо перечислить захватываемые переменные, разделив их запятой, после чего указать ключевое слово `in`. 
Перепишем инициализированное переменной `closureSum` замыкание таким образом, чтобы оно захватывало первоначальные значения переменных `a` и `b`

```swift
var a = 1
var b = 2
let closureSum : () -> Int = { [a, b] in
a + b 
} 
closureSum() // 3 
a = 3 
b = 4 
closureSum() // 3 
```

Замыкание, хранящееся в константе `closureSum`, складывает значения переменных `a` и `b`. При изменении этих значений возвращаемое замыканием значение не меняется. 

### Захват вложенной функцией 

Другим способом захвата значения внешнего параметра является вложенная функция, написанная в теле другой функции. Вложенная функция может захватывать произвольные переменные, константы и даже входные параметры родительской функции. 

```swift
func makeIncrement(forIncrement amount: Int) -> () -> Int {
    var runningTotal = 0
    func increment() -> Int {
        runningTotal += amount
        return runningTotal
    }
    return increment
}
```

Функция `makeIncrement(forIncrement: )` возвращает значение с функциональным типом `() -> Int`. Это значит, что вернется замыкание, не имеющее входных параметров и возвращающее целочисленное значение. 
Функция `makeIncrement(forIncrement:)` использует два параметра: `runningTotal` — переменную типа `Int`, объявленную в теле функции. Именно ее значение является результатом работы всей конструкции;
`amount` — входной параметр, имеющий тип `Int`. Он определяет, насколько увеличится значение `runningTotal` при очередном обращении. 
Вложенная функция `increment()` не имеет входных или объявляемых параметров, но при этом обращается к runningTotal и amount внутри своей реализации. Она делает это в автоматическом режиме путем захвата значений обоих параметров по ссылке. Захват значений по ссылке гарантирует, что измененные значения параметров не исчезнут после окончания работы функции `makeIncrement(forIncrement: )` и будут доступны при повторном вызове функции `increment()`. 

```swift
var incrementByTen = makeIncrement(forIncrement: 10)
var incrementBySeven = makeIncrement(forIncrement: 7)
incrementByTen()      // 10
incrementByTen()      // 20
incrementByTen()      // 30
incrementBySeven()  // 7
incrementBySeven()  // 14
incrementBySeven()  // 21
```

В переменных `incrementByTen` и `incrementBySeven` хранятся возвращаемые функцией `makeIncrement(forIncrement:)` замыкания. В первом случае значение `runningTotal` увеличивается на 10, а во втором — на 7. Каждая из переменных хранит свою копию захваченного значения `runningTotal`, именно поэтому при их использовании увеличиваемые значения не пересекаются и увеличиваются независимо друг от друга. 

Так как в переменных `incrementByTen` и `incrementBySeven` хранятся замыкания, то при доступе к ним после их имени необходимо использовать скобки (по аналогии с доступом к функциям). 

### Замыкания передаются по ссылке (reference type) 

Функциональный тип данных — это **ссылочный тип (reference type)**. Это значит, что замыкания передаются не копированием, а с помощью ссылки на область памяти, где хранится это замыкание. 

```swift
var incrementByFive = makeIncrement(forIncrement: 5)
var copyIncrementByFive = incrementByFive
```

В данном примере используется функция `makeIncrement(forIncrement: )`, объявленная ранее. Напомню, она возвращает замыкание типа `( )->Int`, которое в данном случае предназначено для увеличения значения на 5. Возвращаемое замыкание записывается в переменную `incrementByFive`, после чего копируется в переменную `copyIncrementByFive`. В результате можно обратиться к одному и тому же замыканию, используя как `copyIncrementByFive`, так и `incrementByFive`

```swift
incrementByFive() // 5
copyIncrementByFive() // 10
incrementByFive() // 15
```

Как видите, какую бы функцию мы ни использовали, происходит модификация одного и того же значения (каждое последующее значение больше предыдущего на 5). Это обусловлено тем, что замыкания передаются по ссылке. 

`#Автозамыкания #autoclosure` – это замыкания, которые автоматически создаются из переданного выражения. Иными словами, может существовать функция, имеющая один или несколько входных параметров, которые при ее вызове передаются как значения, но во внутренней реализации функции используются как самостоятельные замыкания. 

```swift
var arrayOfNames = ["Helga", "Bazil", "Alex"]
func printName(nextName: String ) {
    print(nextName)
}
printName(nextName: arrayOfNames.remove(at: 0))  //Helga
```

При вызове функции `printName(nextName: )` в качестве входного значения ей передается результат вызова метода `remove(at: )` массива arrayOfNames. 
Независимо от того, в какой части функции будет использоваться переданный параметр (или не будет использоваться вовсе), значение, возвращаемое методом `remove(at: )`, будет вычислено в момент вызова функции `printName(nextName: )`. Получается, что передаваемое значение вычисляется независимо от того, нужно ли оно в ходе выполнения функции. 

Отличным решением данной проблемы станет использование ленивых вычислений, то есть таких вычислений, которые будут выполняться лишь в тот момент, когда это понадобится. Для того чтобы реализовать этот подход, можно передавать в функцию `printName(nextName:)` замыкание, которое будет вычисляться в тот момент, когда к нему обратятся 

```swift
func printName(nextName: () -> String) {
    // какой-либо код
    print(nextName())
}
printName(nextName: { arrayOfNames.remove(at: 0) }) // Helga 
```

Для решения этой задачи потребовалось изменить тип входного параметра `nextName` на `()->String` и заключить передаваемый метод `remove(at: )` в фигурные скобки. Теперь внутри реализации функции `printName(nextName: )` к входному параметру `nextName` необходимо обращаться как к самостоятельной функции (с использованием круглых скобок после имени параметра). Таким образом, значение метода `remove(at:)` будет вычислено именно в тот момент, когда оно понадобится, а не в тот момент, когда оно будет передано. Единственным недостатком данного подхода является то, что входной параметр должен быть заключен в фигурные скобки, а это несколько усложняет использование функции и чтение кода. 

С помощью автозамыканий можно использовать положительные стороны обоих рассмотренных примеров: отложить вычисление переданного значения и передавать значение в виде значения (без фигурных скобок). 

Для того чтобы реализовать автозамыкание, требуется, чтобы выполнялись следующие требования: 

- Входной параметр должен иметь функциональный тип.
    В примере, приведенном ранее, параметр `nextName` уже имеет функциональный тип `() -> String`. 
- Функциональный тип не должен определять типы входных параметров. 

В примере типы входных параметров не определены (пустые скобки). 

- Функциональный тип должен определять тип возвращаемого значения. 

В примере тип возвращаемого значения определен как String. 

- Переданное выражение должно возвращать значение того же типа, которое определено в функциональном типе замыкания. 

В примере передаваемая в качестве аргумента функция возвращает значение типа String точно так же, как определено функциональным типом входного параметра 

- Перед функциональным типом необходимо использовать атрибут `@autoclosure, #@autoclosure`
- Передаваемое значение должно указываться без фигурных скобок. 


Перепишем код в соответствии с указанными требованиями

```swift
func printName(nextName: @autoclosure() -> String) {
    print(nextName())
}
printName(nextName: arrayOfNames.remove(at: 0)) // Helga 
```

Теперь метод `remove(at:)` передается в функцию `printName(nextName:)` как обычный аргумент, без использования фигурных скобок, но внутри тела используется как самостоятельная функция. 

Выходящие (сбегающие) замыкания 
По умолчанию все переданные в функцию замыкания имеют ограниченную этой функцией область видимости, то есть если вы решите сохранить замыкание для дальнейшего использования, то встретитесь с определенными трудностями. Другими словами, все переданные в функцию замыкания являются не выходящими за пределы ее тела. Если Swift видит, что область, где замыкание доступно, ограничена, он при первой же возможности удалит его, чтобы освободить и не расходовать оперативную память. 
Для того чтобы позволить замыканию выйти за пределы области видимости функции, необходимо указать атрибут @escaping перед функциональным типом при описании входных параметров функции. Для навигации #@escaping #@escaping
Предположим, что в программе есть специальная переменная, предназначенная для хранения замыканий типа () -> Int, то есть являющаяся коллекцией замыканий 
var arrayOfClosures: [()->Int] = []
Пока еще пустой массив arrayOfClosures может хранить в себе замыкания с функциональным типом () -> Int. Реализуем функцию, добавляющую в этот массив переданные ей в качестве аргументов замыкания 
func addNewClosureInArray(_ newClosure: ()->Int) {
    arrayOfClosures.append(newClosure) // ошибка
}
Xcode сообщит вам об ошибке. И на то есть две причины: 
Замыкание — это тип-ссылка (reference type), то есть оно передается по ссылке, но не копированием. 
Замыкание, которое будет храниться в параметре newClosure, будет иметь ограниченную телом функции область видимости, а значит, не может быть добавлено в глобальную (по отношению к телу функции) переменную arrayOfClosures. 
Для решения этой проблемы необходимо указать, что замыкание, хранящееся в переменной newClosure, является выходящим (сбегающим). Для этого перед описанием функционального типа данного параметра укажите атрибут @escaping, после чего вы сможете передать в функцию addNewClosureInArray(_:) произвольное замыкание 
func addNewClosureInArray(_ newClosure: @escaping ()->Int){
    arrayOfClosures.append(newClosure)
}
addNewClosureInArray({return 100})
addNewClosureInArray{return 1000}
arrayOfClosures[0]() // 100
arrayOfClosures[1]() // 1000
Обратите внимание на то, что в одном случае замыкание передается с круглыми скобками, а в другом — без них. Так как функция addNewClosureInArray(_:) имеет один входной параметр, то допускаются оба варианта. 
Если вы передаете замыкание в виде параметра, то можете использовать модификатор inout вместо @escaping. 

Замыкания 
Используются, когда необходимо сгруппировать блок кода для его передачи или многократного использования. В отличие от функций, замыкания не имеют имени. 
Наиболее часто замыкания используются в качестве обработчика завершения (completion handler). При таком подходе они передаются для обработки результатов выполнения другого действия после его завершения. 
К примеру, вам необходимо организовать функцию для осуществления запросов к серверу в Сети. При этом в зависимости от того, какую информацию вы загружаете, вам потребуется по-разному ее обработать. 
   // загрузка новостей с сервера
   webServer.request(url: "https://swiftme.ru/news", completion:
                           {answerData in
       for item in answerData.items {
           // сохранение новостей в базе данных
           saveToDataBase(item)
       }
}) 
   // загрузка лого с сервера
   webServer.request(url: " https://swiftme.ru/logoImage",
                            completion: {answerData in
       // отображение лого на экране устройства
       showLogo.image(answerData)
   })
Метод webServer.request совершает запрос к серверу, при этом в качестве аргументов ему передается адрес, а также замыкание, которое обрабатывает полученный ответ. 
Таким образом, для любого запроса можно использовать один и тот же метод (request), именно он будет нести ответственность за корректность выполнения данной операции. Но обработка ответа будет осуществляться в соответствии с логикой, переданной в замыкании. 
Еще один пример использования замыкания в качестве completion handler — создание UIAlertAction (кнопка на всплывающем уведомлении в iOS). 
   // создание UIAlertController
   let alert = UIAlertController(
       title: "Alert",
       message: "Volume is \(volume)",
       preferredStyle: .alert
   )

   // создание "кнопки" для UIAlertController, при этом передается замыкание, которое, будет выполнено при нажатии на эту кнопку
   let okAction = UIAlertAction(
       title: "Cancel",
       style: .cancel,
       handler:{ (action) in
           resultLabel.text = "Действие выполнено"
       })
   // размещение кнопки на UIAlertController
   alert.addAction(okAction)
Другим популярным примером использования замыканий являются функции высшего порядка. Это такие функции, которые в качестве аргументов принимают другие функции (или замыкания). 
   // передача замыкания в метод filter
   let array = [1, 2, 3, 4, 5]
   let smallerThanThree = array.filter { $0 < 3 }
   // передача замыкания в метод sorted()
   [1,5,1,6,12].sorted() { $0 < $1 }

---

[К оглавлению](#contents)

###  <a id="chapter14" /> Глава №14. Дополнительные возможности. Методы

Метод #map(_:) позволяет применить переданное в него замыкание для каждого элемента коллекции. В результате его выполнения возвращается новая последовательность, тип элементов которой может отличаться от типа исходных элементов 

let myArray = [2, 4, 5, 7]
var newArray = myArray.map{$0}
newArray // [2, 4, 5, 7]
Метод map(_:) принимает замыкание и применяет его к каждому элементу массива myArray. Переданное замыкание {$0} не производит каких-либо действий над элементами, поэтому результат, содержащийся в переменной newArray, не отличается от исходного. 
В данном примере используется сокращенное имя параметра, а именно $0, эта тема была изучена в главе замыкания. Давайте повторим, каким образом функция map(_:) лишилась круглых скобок и приобрела вид map{$0}. 
Метод map(_:) позволяет передать в него замыкание, которое имеет один входной параметр того же типа, что и элементы обрабатываемой коллекции, а также один выходной параметр. Если не использовать сокращенный синтаксис, то вызов метода будет выглядеть следующим образом: 
    let array = [2, 4, 5, 7]
    var newArray = array.map({
        (value: Int) -> Int in
        return value
    })
Замыкание никак не изменяет входной параметр, просто возвращает его. 
Оптимизируем замыкание: 
-сократим код перед ключевым словом in, так как передаваемое замыкание имеет всего один входной параметр; 
-уберем круглые скобки, так как метод map(_:) имеет один входной параметр; 
-уберем оператор return, так как тело замыкания помещается в одно выражение. Получим следующий код: 
    var newArray = array.map{value in value}
Теперь можно убрать ключевое слово in и заменить value на сокр. имя $0: 
var newArray = array.map{$0} 
Изменим так, чтобы map(_:) возводил каждый элемент в квадрат 
newArray = newArray.map{$0*$0}
newArray // [4, 16, 25, 49]
Как говорилось ранее, тип значений результирующей последовательности может отличаться от типа элементов исходной последовательности. Так, например, количество элементов массивов intArray и boolArray одинаково, но тип элементов различается (Int и Bool соответственно). 
let intArray = [1, 2, 3, 4]
let boolArray = intArray.map{$0 > 2}
boolArray // [false, false, true, true]
Каждый элемент последовательности сравнивается с двойкой, в результате чего возвращается логическое значение. 
Вы можете обрабатывать элементы коллекции с помощью метода map(_:) произвольным образом. Пример создания многомерного массива на основе базового. 
let numbers = [1, 2, 3, 4]
let mapped = numbers.map { Array(repeating: $0, count: $0) }
mapped // [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]
Метод map(_:) позволяет обрабатывать элементы любой коллекции, в том числе и словаря. Перевод расстояния, указанного в милях, в километры. 
let milesToDest = ["Moscow":120.0,"Dubai":50.0,"Paris":70.0]
let kmToDest = milesToDest.map { name,miles in [name:miles * 1.6093] }
kmToDest // [["Dubai": 80.465], ["Paris": 112.651], ["Moscow": 193.116]]

Метод mapValues(_:)
Метод #mapValues(_:) позволяет обработать значения каждого элемента словаря, при этом ключи элементов останутся в исходном состоянии 
let mappedCloseStars = ["Proxima Centauri": 4.24, "Alpha Centauri A": 4.37]
let newCollection = mappedCloseStars.mapValues{ $0+1 }
newCollection  // ["Proxima Centauri": "5.24", "Alpha Centauri A": "5.37]
В итоге вы получаете все тот же словарь, но с обработанными значениями

Метод flatMap(_:)
Метод #flatMap(_:) отличается от map(_:) тем, что всегда возвращает плоский одномерный массив. Так, пример, но с использованием flatMap(_:), вернет одномерный массив 
let numbersArray = [1, 2, 3, 4]
let flatMapped = numbersArray.flatMap { Array(repeating: $0, count: $0) }
flatMapped // [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]
Вся мощь flatMap(_:) проявляется тогда, когда в многомерном массиве требуется найти все попадающие под некоторое условие значения 
let someArray = [[1, 2, 3, 4, 5], [11, 44, 1, 6], [16, 403, 321, 10]]
let filterSomeArray = someArray.flatMap{$0.filter{ $0 % 2 == 0}}
filterSomeArray // [2, 4, 44, 6, 16, 10]

Метод compactMap(_:)
Метод #compactMap(_:) позволяет произвести те же действия, что и map(_:), разница лишь в реакции на ситуацию, когда преобразование не может быть произведено. Пример преобразования массива строковых значений в массив значений типа Int. 
let stringArray = ["1", "2", "3", "four", "5"]
let intFromStringArray = stringArray.map() { Int($0) }
intFromStringArray // [1, 2, 3, nil, 5]
Как видно из значения константы intFromStringArray, при неудачной попытке преобразования String в Int в результирующий массив помещается специальное ключевое слово nil. 
Если воспользоваться методом compactMap(_:), то все неуспешные преобразования будут проигнорированы и исключены из результата 
let arrayWitoutNil = stringArray.compactMap() { Int($0) }
arrayWitoutNil // [1, 2, 3, 5]

Метод filter(_:)
Метод #filter(_:) используется, когда требуется отфильтровать элементы коллекции по определенному правилу 

Показана фильтрация всех целочисленных элементов исходного массива, которые делятся на 2 без остатка, то есть всех четных чисел. 
let numArray = [1, 4, 10, 15]
let even = numArray.filter{ $0 % 2 == 0 }
even // [4, 10]

let starDistanceDict = ["Wolf 359": 7.78, "Alpha Centauri B": 4.37, "Barnard's
Star": 5.96]
let closeStars = starDistanceDict.filter { $0.value < 5.0 }
closeStars // ["Alpha Centauri B": 4.37]

Метод reduce(_: _: )
Метод #reduce(_: _: ) позволяет объединить все элементы коллекции в одно значение в соответствии с переданным замыканием. Помимо самих элементов метод принимает первоначальное значение, которое служит для выполнения операции с первым элементом коллекции. 
Предположим, необходимо определить общее количество имеющихся у вас денег. На вашей карте 210 рублей, а в кошельке 4 купюры разного достоинства. Эта задача легко решается с помощью метода reduce(_: _: ) 
let cash = [10, 50, 100, 500]
let total = cash.reduce(210, +) // 870
Первый аргумент — это начальное значение, второй — замыкание, обрабатывающее каждую пару элементов. Первая операция сложения производится между начальным значением и первым элементом массива cash. Результат этой операции складывается со вторым элементом массива и т. д. Замыкание, производящее операцию, может быть произвольным — главное, чтобы оно обрабатывало операцию для двух входящих параметров 

let multiTotal = cash.reduce(210, { $0 * $1 })
multiTotal // 5250000000
let totalThree = cash.reduce(210, {a,b in a-b})
totalThree // -450
Чтобы было легче запомнить: 
если в reduce в качестве второго аргумента передан оператор, то он просто расставляется между элементами коллекции: 
cash.reduce(210, +) = 210 + 10 + 50 + 100 + 500

Функция zip(_: _: )
Функция #zip(_: _: ) предназначена для формирования последовательности пар значений, каждая из которых составлена из элементов двух базовых по- следовательностей. Другими словами, если у вас есть две последовательности и вам нужно попарно брать их элементы, группировать и складывать в новую последовательность, то эта функция как раз то, что нужно. Сначала вы берете первые элементы каждой последовательности, группируете их, потом берете вторые элементы, и т. д. Пример использования функции zip(_: _: ) 
let collectionOne = [1, 2, 3]
let collectionTwo = [4, 5, 6]
let zipSequence = zip(collectionOne, collectionTwo)
type(of: zipSequence) // Zip2Sequence<Array<Int>, Array<Int>>.Type
// генерация массива из сформированной последовательности
Array(zipSequence) // [(.0 1, .1 4), (.0 2, .1 5), (.0 3, .1 6)]
// генерация словаря на основе последовательности пар значений
let newDictionary = Dictionary(uniqueKeysWithValues: zipSequence)
newDictionary // [1: 4, 3: 6, 2: 5]
Еще один новый тип данных Zip2Sequence<Array<Int>, Array<Int>>. 

Оператор guard для опционалов 
Использование оператора #guard при работе с опционалами. 
Иногда вы хотите проверить условие и продолжать выполнение функции, если условие true. Представьте себе функцию, которая извлекает данные из сети. Эта выборка может потерпеть неудачу, если сеть упадет. Обычный способ инкапсулировать это поведение использует optional, который имеет значение, или не имеет его (nil).
Предположим, что название некоторой геометрической фигуры хранится в константе. Вам потребовалось реализовать механизм вывода на консоль сообщения, содержащего информацию о количестве сторон в данной фигуре. Для реализации задуманного напишем две функции: 
Первая — countSidesOfShape возвращает количество сторон фигуры по ее названию. 
Вторая — maybePrintCountSides выводит необходимое сообщение на консоль. 
Почему лучше написать две функции вместо одной? Так как ваша программа предназначена для работы с геометрическими фигурами, то функция countSidesOfShape может потребоваться вам и для других целей. По этой причине имеет смысл разбить функционал. 
Так как вы не можете заранее предусмотреть все варианты геометрических фигур, то в случае обработки неизвестной фигуры программа должна выводить сообщение о том, что количество сторон неизвестно. Реализуем функцию с именем countSidesOfShape 
func countSidesOfShape(shape: String) -> Int? {
    switch shape {
    case "треугольник":
        return 3;
    case "квадрат":
        return 4;
    case "прямоугольник":
        return 4;
   default: 
   return nil; 
   } 
 } 

Далее реализуем функцию maybePrintCountSides(shape: ), принимающую на вход название фигуры 
func maybePrintSides(shape: String) {
  let sides = calculateNumberOfSides(shape: shape)

  if let sides = sides {
    print("A \(shape) has \(sides) sides.")
  } else {
    print("I don’t know the number of sides for \(shape).")
  }
}
or
func maybePrintCountSides(shape: String) {
    if let sides = countSidesOfShape(shape: shape) {
        print("A \(shape) has \(sides) sides.ны")
    } else {
        print("I don’t know the number of sides for \(shape).")
    }
} 

Для получения количества сторон используется оператор условия if, осуществляющий проверку операции опционального связывания. Логика работы функции состоит в том, что если фигура отсутствует в базе, не имеет смысла выполнять функцию: можно вывести информационное сообщение и досрочно завершить ее работу. Для этого можно использовать оператор раннего выхода guard 
func maybePrintSides(shape: String) {
  guard let sides = calculateNumberOfSides(shape: shape) else {
    print("I don’t know the number of sides for \(shape).")
    return
  }

  print("A \(shape) has \(sides) sides.")
}
Оператор guard проверяет, возможно ли провести операцию опционального связывания, и в случае отрицательного результата выполняет код тела оператора, т.е код в теле оператора guard выполняется только когда false, где с помощью return досрочно завершается работа функции. 
Если опциональное связывание успешно завершается, то тело guard игнорируется и выполняет следующий за ним код. 
С помощью guard код функции стал значительно более читабельным. Особенно это заметно, если код, следующий за оператором, будет занимать больше одной строки. С его помощью вы проверяете возможность получения всех необходимых параметров до того, как перейдете к выполнению кода функции. 

Оператор отложенных действий defer 
Оператор #defer откладывает выполнение определенного в его теле кода до момента выхода из области видимости, в которой он был использован (например, после окончания выполнения функции). 
func someFunction() {
    defer {
        print("action in defer")
    }
    defer { 
        print("another action in defer")
    }
    print("action in function")
}
someFunction()
Консоль: 
action in function
another action in defer
action in defer
Как видно из примера, отложенные действия были выполнены после того, как функция завершила свою работу, и что важно, они выполнялись в обратном порядке: сперва блок последнего оператора defer, затем предпоследнего и т. д. 
Вы можете использовать defer для выполнения любых отложенных действий, очистки и удаления использованных ресурсов, закрытия файлов, логирования и т. д. 

---

[К оглавлению](#contents)

###  <a id="chapter15" /> Глава №15. Ленивые вычисления 

«Ленивый» в Swift звучит как #lazy. Можно сказать, что lazy — синоним производительности. Хорошо оптимизированные программы практически всегда используют ленивые вычисления.
В программировании #ленивыми называются такие элементы, вычисление значений которых откладывается до момента обращения к ним. Таким образом, пока значение не потребуется и не будет использовано, оно будет храниться в виде сырых исходных данных. С помощью ленивых вычислений достигается экономия процессорного времени, то есть компьютер не занимается ненужными в данный момент вычислениями. 
Существует два типа ленивых элементов:

- #lazy-by-name — значение элемента вычисляется при каждом обращении к нему; 
- #lazy-by-need — элемент вычисляется один раз при первом обращении к нему, после чего фиксируется и больше не изменяется. 

Замыкания в ленивых вычислениях 
С помощью замыканий мы можем создавать ленивые конструкции типа lazy-by-name, значение которых высчитывается при каждом обращении к ним
var arrayOfNames = ["Helga", "Bazil", "Alex"]
print(arrayOfNames.count)
let nextName = { arrayOfNames.remove(at: 0) }
arrayOfNames.count //3
nextName()
arrayOfNames.count //2
В константе nextName хранится замыкание, удаляющее первый элемент массива arrayOfNames. Несмотря на то что константа объявлена, а ее значение проинициализировано, количество элементов массива не уменьшается до тех пор, пока не произойдет обращение к хранящемуся в ней замыканию. 
Если пойти дальше, то можно сказать, что любая функция или метод являются lazy-by-name, так как их значение высчитывается при каждом обращении. 

Свойство lazy 
Некоторые конструкции языка Swift (например, массивы и словари) имеют свойство lazy, позволяющее преобразовать их в ленивые. Наиболее часто это происходит, когда существуют цепочки вызова свойств или методов и выделение памяти, и вычисление промежуточных значений является бесполезной тратой ресурсов, так как эти значения никогда не будут использованы. 
Рассмотрим следующий пример: существует массив целых чисел, значения которого непосредственно не используются в работе программы. Вам требуется лишь результат его обработки методом map(_:), и то не в данный момент, а позже 
let baseCollection = [1,2,3,4,5,6]
let myLazyCollection = baseCollection.lazy
type(of:myLazyCollection) // LazySequence<Array<Int>>.Type
let collection = myLazyCollection.map{$0 + 1}
type(of:collection) // LazyMapSequence<Array<Int>, Int>.Type
В результате выполнения возвращается ленивая коллекция. При этом память под отдельный массив целочисленных значений не выделяется, а вычисления метода map(_:) не производятся до тех пор, пока не произойдет обращение к константе collection. 
Вся прелесть такого подхода в том, что вы можете увеличивать цепочки вызовов, но при этом лишнего расхода ресурсов не будет 
let resultCollection = [1,2,3,4,5,6].lazy.map{$0 + 1}.filter{$0 % 2 == 0}
Array(resultCollection) // [2, 4, 6]

---

[К оглавлению](#contents)

### Часть IV ВВЕДЕНИЕ В РАЗРАБОТКУ ПРИЛОЖЕНИЙ 

###  <a id="chapter16" /> Глава №16. Консольные приложения

### «Сумма двух чисел» 

Выберите пункт macOS. 
Выберите шаблон Command Line Tool.
Шаблон Command Line Tool используется при создании приложений, функционирующих в среде командной строки. 
Product Name — название будущего проекта. Введите Swiftme-FirstApp. 
Team — так как мы не планируем размещать программу в магазине приложений, данный пункт оставим без изменений. 
Organization Identifier — идентификатор вашего разработчика. Обычно в качестве идентификатора используют перевернутое доменное имя вашей организации, например com.myorganization. При этом Xcode не связывается с каким-либо доменом в сети, его цель состоит лишь в том, чтобы однозначно идентифицировать разработчика. Должен быть уникальным среди всех разработчиков, размещающих свои приложения в AppStore. 
Bundle Identifier — данная строка генерируется автоматически на основе Organization Identifier и Product Name. Это уникальный идентификатор вашего приложения. Он чувствителен к регистру. 
Language — язык программирования, на котором будет написано ваше приложение. 
Toolbar — панель инструментов. 
Navigator — панель навигации, позволяющая производить навигацию по различным элементам проекта. 
Inspectors — панель настроек, отображающая свойства активного элемента. 
Project editor — редактор и основная рабочая площадка проекта.
Debug area — панель отладки

<img alt="image" src="images/view xcode.jpg"/>

<img alt="image" src="images/Toolbar view.jpg"/>

Для отображения области отладки (Debug Area) нажать CMD+SHIFT+C или View > Debug Area > Activate Console 

Консольные приложения в macOS запускаются и работают в среде программы Терминал, в папке Программы > Утилиты

У любой программы, написанной на Swift, есть так называемая точка входа, то есть файл с исходным кодом, который будет первым загружен и проанализирован компилятором. Это касается как консольных приложений, так и приложений под iOS. В данном случае точкой входа является файл main.swift, и если вы переименуете его, то при запуске проекта получите сообщение об ошибке. Файлы с расширением .swift содержат исходный код

Разрабатываемая программа должна запрашивать у пользователя два значения, производить их сложение и выводить результат на консоль. Для получения значений, вводимых с клавиатуры, в консольных приложениях служит функция #readLine(). Она ожидает ввода данных с клавиатуры с последующим нажатием кнопки Enter, после чего возвращает значение типа String? (опциональный строковый тип данных). 
print("Введите первое значение")
// получение первого значения
var a = readLine()
print("Введите второе значение")
// получение второго значения
var b = readLine()
С помощью данного кода у пользователя будут запрашивать значения параметров a и b 
Следующей задачей станет подсчет суммы введенных значений. Для этого требуется создать специальную функцию sum(_: _: ), принимающую на вход два значения типа String? в качестве операндов операции сложения. Немного оптимизируем структуру, написав sum(_: _: ) в отдельном файле 
Добавим в проект новый файл: 

- Правой кнопкой мыши щелкните на папке SwiftmeFirstApp в Navigator. 
- В появившемся меню выберите пункт New File. 
- В появившемся окне выберите Swift File 

В данном файле мы реализуем функцию sum(_: _: ), предназначенную для сложения двух чисел. Входные параметры функции будут иметь тип String? (соответствует типу возвращаемого функцией readLine() значения), а внутри ее реализации перед операцией сложения — преобразовываться к Int. 
На панели Toolbar нажмите кнопку Library  
В появившемся окне нажмите кнопку Show the Snippets Library   
C помощью поля поиска отфильтруйте сниппеты по слову func. 
Среди элементов щелкните на Function Statement. 

Выделив поле name в шаблоне, вы сможете ввести имя функции, а с помощью клавиши Tab на клавиатуре — перескакивать к следующему требуемому полю. Используя созданный шаблон, напишите функцию sum(_:  _:  ) 
func sum(_ a: String?, _ b: String?) -> Int {
    return Int(a!)! + Int(b!)!
}
Значение, переданное на вход функции Int(_:), не должно быть опциональным. С этим связан знак принудительного извлечения опционального значения внутри Int(_:), то есть первый знак восклицания. 
Оператор сложения внутри функции sum(_:_:) может производить операцию сложения только с неопциональными значениями, в то время как функция Int(_:) в качестве результата своей работы возвращает значение типа Int?. Именно по этой причине ставится второй восклицательный знак. 
Несмотря на то что функция sum(_: _: ) описана в файле func.swift, она может использоваться и в других файлах проекта. 
Добавьте в конец файла main.swift код 
let result = sum(a, b)
print("Результат сложения - \(result)")

---

[К оглавлению](#contents)

###  <a id="chapter17" /> Глава №17. Консольная игра «Угадай число» 

Компьютер загадывает целое число в диапазоне от 1 до 50, а игрок пытается угадать его за минимальное количество ходов. После каждой попытки приложение должно сообщать, как введенное число соотносится с загаданным — больше, меньше или равно ему. 
Наша будущая игра будет функционировать по следующему алгоритму: 
Генерация случайного числа -> 
Запрос числа у пользователя -> 
Сопоставление сгенерированного числа с запрошенным ->
Вывод результата сопоставления ->
Если числа одинаковы, то работа программы завершается ->
Если числа различны, то происходит переход к шагу 2. 
В файле main.swift реализуем механизм генерации случайного числа 
// генерация случайного числа
let randomNumber = UInt8.random(in: 1...250)
    Константа randomNumber содержит случайно сгенерированное число. 
Несколько слов об оптимизации приложения. В общем случае любая оптимизация — это поиск компромисса, обычно между памятью и процессорным временем устройства. Обратите внимание, что в качестве типа данных константы randomNumber используется UInt8. Если не определить тип данных самостоятельно, то Swift автоматически определит его как Int, а это 64 бита памяти вместо 8 бит. Да, конечно, в данном случае экономия не имеет какой-либо практической пользы, но я настоятельно советую вам привыкать к процессу оптимизации. Тем не менее порой вы можете пойти на некоторые траты ресурсов в угоду читабельности кода, но я советую вам думать об оптимизации при написании любого кода. 
Шаги 2–6 описанного выше алгоритма — это цикл. Ваша программа не должна завершать работу до тех пор, пока число не будет отгадано. Для реализации этого условия лучше использовать конструкцию repeat while
import Foundation
// генерация случайного числа
let randomNumber = UInt8.random(in: 1...250)
print("Компьютер случайным образом загадал число. Вам требуется отгадать его.")
// в переменную будет записываться число с консоли
var myNumber: String?
// цикл с постпроверкой условия
repeat {
    print("Введите ваш вариант и нажмите Enter")
    // получение значения с клавиатуры пользователя
    myNumber = readLine()
    // сравнение введенного и сгенерированного чисел
    if (UInt8(myNumber!) == randomNumber) {
        print("Вы угадали!")
    } else if (UInt8(myNumber!)! < randomNumber) {
        print("Ваш вариант меньше загаданного числа")
    } else if (UInt8(myNumber!)! > randomNumber) {
        print("Ваш вариант больше загаданного числа")
    }
} while randomNumber != UInt8(myNumber!)

<img alt="image" src="images/Консольная игра Угадай число.jpg"/>

Устраняем ошибки приложения 
Выделим основные проблемы программы: 
-Аварийное завершение работы приложения при вводе нецифровых символов. 
-Аварийное завершение работы приложения при вводе числа больше 255 (верхняя граница типа UInt8).
-При доступе к значению опционала используется принудительное извлечение значения там, где это может привести к аварийному завершению. 
-Многократное приведение к типу UInt8. 
Решение:

```swift
print("Компьютер случайным образом загадал число. Вам требуется отгадать его.")

// Случайное число
let randomNumber = UInt8.random(in: 1...250)
print("Введите вариант числа от 1 до 250 и нажмите Enter")

// флаг-указатель на победу
var isWin = false
repeat {
          // попытка преобразования введенного значения к UInt8
          guard let userNumber = UInt8(readLine() ?? "") else {
              print("Вы ввели некорректное число. Попробуйте снова")
              continue 
          } 

          // проверка введенного числа
          if userNumber < randomNumber{
          print("Ваш вариант меньше загаданного числа")
          } else if userNumber > randomNumber {
          print("Ваш вариант больше загаданного числа")
          } else {
          print("Вы угадали")
          isWin = true 
          } 
} while !isWin
```

---

[К оглавлению](#contents)

Часть V. НЕТРИВИАЛЬНЫЕ ВОЗМОЖНОСТИ SWIFT. 

###  <a id="chapter18" /> Глава №18. Введение в объектно-ориентированное и протокол-ориентированное программирование 



---

[К оглавлению](#contents)

###  <a id="chapter19" /> Глава №19. 



---

[К оглавлению](#contents)

###  <a id="chapter20" /> Глава №20. 



---

[К оглавлению](#contents)

###  <a id="chapter21" /> Глава №21. 



---

[К оглавлению](#contents)

###  <a id="chapter22" /> Глава №22. 



---

[К оглавлению](#contents)

###  <a id="chapter23" /> Глава №23. 



---

[К оглавлению](#contents)

###  <a id="chapter24" /> Глава №24. 



---

[К оглавлению](#contents)

###  <a id="chapter25" /> Глава №25. 



---

[К оглавлению](#contents)

###  <a id="chapter26" /> Глава №26. 



---

[К оглавлению](#contents)

###  <a id="chapter27" /> Глава №27. 