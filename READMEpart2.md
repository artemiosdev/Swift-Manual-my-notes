Вторая часть коспекта, из-за ограничей Github был разделен единый файл коспекта на части.
[1 часть коспекта](https://github.com/artemiosdev/Swift-Manual-my-notes)

- [Глава  №13. Замыкания (closure). ](#chapter13)
- [Глава  №14. Дополнительные возможности. Методы. ](#chapter14)
- [Глава  №15. Ленивые вычисления. ](#chapter15)

Часть IV ВВЕДЕНИЕ В РАЗРАБОТКУ ПРИЛОЖЕНИЙ

- [Глава  №16. Консольные приложения. ](#chapter16)
- [Глава  №17. Консольные приложение "Угадай число". ](#chapter17)
- [Глава  №18. Введение в объектно-ориентированное и протокол-ориентированное программирование. ](#chapter18)
- [Глава  №19. . ](#chapter19)
- [Глава  №20. . ](#chapter20)
- [Глава  №21. . ](#chapter21)
- [Глава  №22. . ](#chapter22)
- [Глава  №23. . ](#chapter23)
- [Глава  №24. . ](#chapter24)
- [Глава  №25. . ](#chapter25)
- [Глава  №26. . ](#chapter26)
- [Глава  №27. . ](#chapter27)

###  <a id="chapter13" /> Глава №13. Замыкания (closure) 

#Замыкания (closures) — это организованные блоки с определенной функциональностью, которые могут быть переданы и использованы в коде. 

Замыкания #closure, или замыкающие выражения, — это сгруппированный программный код, который может быть передан в виде параметра и многократно использован. Ничего не напоминает? Если вы скажете, что в этом определении узнали функции, то будете полностью правы. 

### Виды замыканий 

Как вы знаете, параметры предназначены для хранения информации, а функции могут выполнять определенные задачи. Говоря простым языком, **с помощью замыканий вы можете поместить блок исполняемого кода в переменную или константу, свободно передавать ее и при необходимости вызывать хранящийся в ней код**. Вы уже видели подобный подход при изучении функций. Дело в том, что **функции — это частный случай замыканий**. 

В общем случае замыкание (closure) может принять две формы: 

- именованная функция;
- безымянная функция, определенная с помощью облегченного синтаксиса. 

Далее **#безымянные функции будут именоваться замыканиями**, или замыкающими выражениями. Говоря о функции, мы будем иметь в виду именно функции, а говоря о **замыканиях — безымянные функции**. 

### Введение в безымянные функции (замыкания) 

Как вы уже знаете, переменная и константа может хранить в себе ссылку на функцию. Но для того, чтобы организовать это, не обязательно возвращать одну функцию из другой. Вы можете использовать специальный облегченный синтаксис, создав безымянную функцию, после чего передать ее в качестве значения в требуемый параметр. Безымянные функции не имеют имен. Они состоят только из тела, заключенного в фигурные скобки. 

```swift
   { (входные_параметры) -> ТипВозвращаемогоЗначения in
       // тело замыкающего выражения
   }
```

`входные_параметры` — список аргументов замыкания с указанием их имен и типов. 

`ТипВозвращаемогоЗначения` — тип данных значения, возвращаемого замыканием.

Замыкающее выражение пишется в фигурных скобках. После указания перечня входных аргументов и типа возвращаемого значения ставится ключевое слово `in`, после которого следует тело замыкания. 

В самом простом случае можно опустить указание входных параметров и тип выходного значения, оставив лишь тело замыкания. 

```swift
// безымянная функция в качестве значения константы
let functionInLet = { return true }
// вызываем безымянную функцию
functionInLet() // true
```

Константа `functionInLet` имеет функциональный тип `() -> Bool` (ничего не принимает на вход, но возвращает логическое значение) и хранит в себе тело функции. 
Обратите внимание, что при инициализации безымянной функции в параметр для ее вызова используется имя параметра с круглыми скобками. 

В нашей программе объявлена переменная `wallet`, хранящая в себе программный аналог кошелька с купюрами (в пред. главе мы уже использовали массив-кошелек). Каждый элемент этой коллекции представляет собой одну банкноту опред. номинала. Перед нами стоит задача отбора банкнот в кошельке по различным условиям. Для каждого условия может быть создана отдельная функция, принимающая на вход массив wallet и возвращающая отфильтрованную коллекцию. 

```swift
// массив с купюрами
var wallet = [10,50,100,100,5000,100,50,50,500,100]
// функция отбора купюр
func handle100(wallet: [Int]) -> [Int] {
    var returnWallet = [Int]()
    for banknote in wallet {
        if banknote == 100 {
            returnWallet.append(banknote)
        }
    } 
    return returnWallet
}
// вызов функции отбора купюр с достоинством 100
handle100(wallet: wallet) // [100, 100, 100, 100]
```

При каждом вызове функция `handle100(wallet: )` будет возвращать массив сторублевых купюр переданного массива-кошелька. 
Но условия отбора не ограничиваются данной функцией. Расширим функционал нашей программы, написав дополнительную функцию для отбора купюр достоинством 1000 рублей и более 

```swift
func handleMore1000(wallet: [Int]) -> [Int] {
    var returnWallet = [Int]()
    for banknote in wallet {
        if banknote >= 1000 {
            returnWallet.append(banknote)
        }
} 
    return returnWallet
}
// вызов функции отбора купюр с достоинством более или равно 1000
handleMore1000(wallet: wallet) // [5000]
```

В результате для отбора купюр по требуемым условиям реализовано уже две функции: `handle100(wallet: )` и `handleMore1000(wallet: )`. При этом тела обеих функций очень похожи, разница лишь в проверяемом условии, остальной код в функциях один и тот же. 
Для решения проблемы дублирования можно пойти двумя путями: 

- реализовать всю функциональность отбора купюр в пределах одной функции, а в качестве аргумента передавать условие; 
- реализовать всю функциональность в виде трех функций. Первая будет группировать повторяющийся код и принимать в виде аргумента одну из двух других функций. Переданная функция будет производить проверку условия в теле главной функции.

Если выбрать первый путь, то при увеличении количества условий отбора единая функция будет разрастаться и в конце концов станет нечитабельной и слишком сложной. Плюс к этому необходимо придумать, каким образом передавать указатель на проверяемое условие, а значит, потребуется вести документацию к данной функции. 

По этой причине воспользуемся вторым вариантом, реализуем функционал в виде трех функций: 

- Функция с именем `handle`, принимающая массив-кошелек и условие отбора (в виде имени функции) в качестве аргументов и возвращающая массив отобранных купюр. В теле функции будут поочередно проверяться элементы входного массива на соответствие переданному условию. 

- Функция с именем `compare100`, принимающая на вход значение очередного элемента массива-кошелька, производящая сравнение с целым числом 100 и возвращающая логический результат этой проверки. 

- Функция с именем `compareMore1000`, аналогичная `compare100`, но производящая проверку на соответствие целому числу 1000. 

```swift
// единая функция формирования результирующего массива
func handle(wallet: [Int], closure: (Int) -> Bool) -> [Int] {
    var returnWallet = [Int]()
    for banknote in wallet {
        if closure(banknote) {
            returnWallet.append(banknote)
        }
    } 
    return returnWallet
}
// функция сравнения с числом 100
func compare100(banknote: Int) -> Bool {
    return banknote == 100
}
// функция сравнения с числом 1000
func compareMore1000(banknote:Int) -> Bool {
    return banknote >= 1000
}
// отбор
let resultWalletOne = handle(wallet: wallet, closure: compare100)
let resultWalletTwo = handle(wallet: wallet, closure: compareMore1000)
```

Функция `handle(wallet:closure: )` получает в качестве входного параметра `closure` одну из функций проверки условия и в операторе `if` вызывает переданную функцию. Функции проверки принимают на вход анализируемую купюру и возвращают `Bool` в зависимости от результата сравнения. Чтобы получить купюры определенного достоинства, необходимо вызвать функцию `handle(wallet: closure: )` и передать в нее имя одной из функций проверки. 

Представим, что возникла необходимость написать функции для отбора купюр по многим и многим условиям, найти все полтинники; все купюры достоинством менее 1000 рублей; все купюры, которые без остатка делятся на 200, и т. д. В определенный момент писать отдельную функцию проверки для каждого из них станет довольно тяжелой задачей, так как для того, чтобы использовать единую функцию проверки, необходимо знать имя проверяющей функции, а их могут быть десятки. 
В подобной ситуации можно отказаться от создания отдельных функций и передавать в `handle(wallet: closure: )` условие отбора в виде безымянной функции. 

```swift
// отбор купюр достоинством выше 1000 рублей
// аналог передачи compareMore1000
handle(wallet: wallet, closure: { (banknote: Int) -> Bool in
    return banknote >= 1000
})
// отбор купюр достоинством 100 рублей
// аналог передачи compare100
handle(wallet: wallet, closure: { (banknote: Int) -> Bool in
    return banknote == 100
})
```

Входной параметр `closure` имеет функциональный тип `(Int)->Bool`, а значит, передаваемая безымянная функция должна иметь тот же тип данных, что мы видим в коде. 

Для переданного замыкания указан входной параметр типа `Int` и определен тип возвращаемого значения `(Bool)`. После ключевого слова `in` следует тело функции, в котором с помощью оператора `return` возвращается логическое значение – результат проверки очередного элемента кошелька. Таким образом, в теле функции `handle(wallet: closure: )` будет вызываться не какая-то внешняя функция, имя которой передано, а безымянная функция, переданная в виде входного параметра. 

В результате такого подхода необходимость в существовании функций `compare100(banknote: )` и `compareMore1000(banknote: )` отпадает, так как код условия передается напрямую в качестве замыкания в аргумент `closure`. 

### Возможности замыканий. Пропуск указания типов 

При объявлении входного параметра `closure` в функции `handle(wallet: closure: )` указывается его функциональный тип `(Int)->Bool`, поэтому при передаче замыкающего выражения можно опустить данную информацию, оставив лишь имя аргумента 

```swift
// отбор купюр достоинством выше 1000 рублей
handle(wallet: wallet, closure: { banknote in
    return banknote >= 1000
})
```

В замыкающем выражении перед ключевым словом `in` необходимо указать только имя параметра без входных и выходных типов. 

### Неявное возвращение значения 

Если тело замыкающего выражения содержит всего одно выражение, которое возвращает некоторое значение (с использованием оператора `return`), то такие замыкания могут неявно возвращать выходное значение. «Неявно» — значит, без использования оператора `return`

`handle(wallet: wallet, closure: { banknote in banknote >= 1000})`

### Сокращенные имена параметров `$номер_параметра`

В случае, когда замыкание состоит из одного выражения, можно опустить указание входных параметров (все до ключевого слова `in`, включая само слово). При этом доступ к входным параметрам внутри тела замыкания необходимо осуществлять через сокращенные имена в форме `$номер_параметра`. Номера входных параметров начинаются с нуля. (Знак `#$`)

В сокращенной форме записи имен входных параметров обозначение `$0` указывает на первый передаваемый аргумент. 

Для доступа ко второму аргументу необходимо использовать обозначение `$1`, к третьему — `$2` и т. д. 
Перепишем вызов функции `handle(wallet: closure: )` с использованием сокращенных имен 

`handle(wallet: wallet, closure: {$0>=1000})`

Здесь `$0` — это входной параметр `banknote` аргумента closure в функции `handle(wallet: closure: )`. 
Было изначально так :

```swift
handle(wallet: wallet, closure: { (banknote: Int) -> Bool in
    return banknote >= 1000
})
```

### Вынос замыкания за скобки 

Если входной параметр функции расположен последним в списке входных параметров функции (как в данном случае в функции `handle(wallet: closure: )`, где параметр closure является последним), Swift позволяет вынести его значение (тело замыкающего выражения) за круглые скобки 

`handle(wallet: wallet){ $0 >= 1000 }`

Эта возможность особенно полезна, когда замыкание, передаваемое в качестве аргумента функции, является многострочным. Пример выноса замыкания, состоящего из нескольких выражений. С его помощью производится сравнение элементов с массивом «разрешенных» купюр. В результирующей коллекции будут находиться только те купюры, которые являются «разрешенными». 

```swift
handle(wallet: wallet) { banknote in
    for number in Array(arrayLiteral: 100,500) {
        if number == banknote {
            return true 
       } 
  } 
      return false
  }
```

Существует и другой способ реализовать проверку из предыдущего листинга. Для этого можно использовать метод `contains(_: )`, передавая в него очередную купюру: 

```swift
var wallet = [10,50,100,100,5000,100,50,50,500,100]
let successBanknotes = handle(wallet: wallet) { [100,500].contains($0) }
successBanknotes // [100, 100, 100, 500, 100]
```

### Вынос нескольких замыканий за скобки

Начиная с версии 5.3, в Swift появилась возможность вынести за скобки не одно, а все замыкания, находящиеся в конце списка аргументов. Предположим, что вы написали функцию, осуществляющую запрос на сервер.

```swift
func networkQuery(url: String, success: (String) -> (), error: (Int) -> ()) {
    // код запроса на сервер
}
```

В качестве аргументов в функцию передаются URL-адрес и два замыкания: первое будет вызвано в случае успешного окончания запроса, а второе — в случае ошибки. При вызове функции `networkQuery` вы можете использовать как стандартный синтаксис, указывая замыкания прямо в списке аргументов, так и упрощенный, вынеся оба замыкания за скобки 

```swift
// классический вариант
networkQuery(url: "https://weather.com", success: { data in }, error: {errorCode in })

// новый вариант
networkQuery(url: "https://weather.com") { data in
    // ...
} error: { errorCode in
// ... } 
```

Данная возможность будет использоваться вами очень часто при работе с фреймворком `SwiftUI`. 

### Безымянные функции в параметрах () -> Void 

Пример инициализации замыкания в параметр `closure`. При этом у параметра явно указан функциональный тип (ранее в примерах он определялся неявно). 

```swift
let closure: () -> Void = {
    print("Замыкающее выражение")
}
closure() 
// Консоль: Замыкающее выражение
```

Так как данное замыкающее выражение не имеет входных параметров и возвращаемого значения, то его тип равен `() -> Void`. Для вызова, записанного в константу замыкающего выражения, необходимо написать имя константы с круглыми скобками, точно так же, как мы делали это ранее. 

Явное указание функционального типа позволяет определить входные параметры и тип выходного значения 

```swift
// передача в функцию строкового значения
let closurePrint: (String) -> Void = { text in
    print(text)
}
closurePrint("Text")
// Консоль: Text 

// передача в функцию целочисленных значений
// с осуществлением доступа через краткий синтаксис $0 и $1
var sum: (_ numOne: Int, _ numTwo: Int) -> Int = { $0 + $1 } 
sum(10, 34) // 44
```

Ключевое слово `return` не используется в замыкании sum, так как его тело состоит из одного выражения. 

### Пример использования замыканий при сортировке массива 

Одним из таких методов является `#sorted(by: )`, предназначенный для сортировки массивов, как строковых, так и числовых. Он принимает на входе массив, который необходимо отсортировать, и условие сортировки. 

Принимаемое условие сортировки — это обыкновенное замыкающее выражение, которое вызывается внутри метода `sorted(by: )`, принимает на входе два очередных элемента сортируемого массива и возвращает значение Bool в зависимости от результата их сравнения. 
Ниже массив `array` сортируется таким образом, чтобы элементы были расположены по возрастанию. Для этого в метод `sorted(by: )` передается замыкающее выражение, которое возвращает true, когда второе из сравниваемых чисел больше. 

```swift
let array = [1,44,81,4,277,50,101,51,8]
var sortedArray = array.sorted(by: { (first: Int, second: Int) -> Bool in
    return first < second
})
sortedArray // [1, 4, 8, 44, 50, 51, 81, 101, 277]
```

Теперь применим все рассмотренные ранее способы оптимизации замыкающих выражений:

- уберем функциональный тип замыкания;
- уберем оператор return;
- заменим имена переменных именами сокращенной формой. 

В результате получится выражение ниже. Как и в предыдущем примере, здесь тоже необходимо отсортировать массив `array` таким образом, чтобы элементы были расположены по возрастанию. Для этого в метод `sorted(by:)` передается такое замыкающее выражение, которое возвращает true, когда второе из сравниваемых чисел больше. Сокращенный вариант

```swift
let array = [1,44,81,4,277,50,101,51,8]
var sortedArray = array.sorted(by: { $0 < $1 })
sortedArray // [1, 4, 8, 44, 50, 51, 81, 101, 277]
```

В результате код получается более читабельным и красивым. 
Супер сокращенный вариант. Но и это еще не все. Так как выражение в замыкании состоит всего из одного бинарного оператора, то можно убрать даже имена параметров, оставив лишь оператор сравнения 

```swift
let array = [1,44,81,4,277,50,101,51,8]
var sortedArray = array.sorted(by: <)
sortedArray // [1, 4, 8, 44, 50, 51, 81, 101, 277]
```

### Захват переменных. Синтаксис захвата переменных 

Существуют два параметра, `a` и `b`, которые не передаются в качестве аргументов в замыкание, но используются им в вычислениях. При каждом вызове такого замыкания оно будет определять значения данных параметров, прежде чем приступить к выполнению операции с их участием. 

```swift
var a = 1
var b = 2
let closureSum: () -> Int = { a + b }
closureSum() // 3 
a = 3
b = 4 
closureSum() // 7 
```

Замыкание, хранящееся в константе `closureSum`, складывает значения переменных `a` и `b`. При изменении их значений возвращаемое замыканием значение меняется. 
Существует способ **«захватить»** значения параметров, то есть зафиксировать те значения, которые имеют эти параметры на момент объявления замыкающего выражения. Для этого в начале замыкания в квадратных скобках необходимо перечислить захватываемые переменные, разделив их запятой, после чего указать ключевое слово `in`. 
Перепишем инициализированное переменной `closureSum` замыкание таким образом, чтобы оно захватывало первоначальные значения переменных `a` и `b`

```swift
var a = 1
var b = 2
let closureSum : () -> Int = { [a, b] in
a + b 
} 
closureSum() // 3 
a = 3 
b = 4 
closureSum() // 3 
```

Замыкание, хранящееся в константе `closureSum`, складывает значения переменных `a` и `b`. При изменении этих значений возвращаемое замыканием значение не меняется. 

### Захват вложенной функцией 

Другим способом захвата значения внешнего параметра является вложенная функция, написанная в теле другой функции. Вложенная функция может захватывать произвольные переменные, константы и даже входные параметры родительской функции. 

```swift
func makeIncrement(forIncrement amount: Int) -> () -> Int {
    var runningTotal = 0
    func increment() -> Int {
        runningTotal += amount
        return runningTotal
    }
    return increment
}
```

Функция `makeIncrement(forIncrement: )` возвращает значение с функциональным типом `() -> Int`. Это значит, что вернется замыкание, не имеющее входных параметров и возвращающее целочисленное значение. 
Функция `makeIncrement(forIncrement:)` использует два параметра: `runningTotal` — переменную типа `Int`, объявленную в теле функции. Именно ее значение является результатом работы всей конструкции;
`amount` — входной параметр, имеющий тип `Int`. Он определяет, насколько увеличится значение `runningTotal` при очередном обращении. 
Вложенная функция `increment()` не имеет входных или объявляемых параметров, но при этом обращается к runningTotal и amount внутри своей реализации. Она делает это в автоматическом режиме путем захвата значений обоих параметров по ссылке. Захват значений по ссылке гарантирует, что измененные значения параметров не исчезнут после окончания работы функции `makeIncrement(forIncrement: )` и будут доступны при повторном вызове функции `increment()`. 

```swift
var incrementByTen = makeIncrement(forIncrement: 10)
var incrementBySeven = makeIncrement(forIncrement: 7)
incrementByTen()      // 10
incrementByTen()      // 20
incrementByTen()      // 30
incrementBySeven()  // 7
incrementBySeven()  // 14
incrementBySeven()  // 21
```

В переменных `incrementByTen` и `incrementBySeven` хранятся возвращаемые функцией `makeIncrement(forIncrement:)` замыкания. В первом случае значение `runningTotal` увеличивается на 10, а во втором — на 7. Каждая из переменных хранит свою копию захваченного значения `runningTotal`, именно поэтому при их использовании увеличиваемые значения не пересекаются и увеличиваются независимо друг от друга. 

Так как в переменных `incrementByTen` и `incrementBySeven` хранятся замыкания, то при доступе к ним после их имени необходимо использовать скобки (по аналогии с доступом к функциям). 

### Замыкания передаются по ссылке (reference type) 

Функциональный тип данных — это **ссылочный тип (reference type)**. Это значит, что замыкания передаются не копированием, а с помощью ссылки на область памяти, где хранится это замыкание. 

```swift
var incrementByFive = makeIncrement(forIncrement: 5)
var copyIncrementByFive = incrementByFive
```

В данном примере используется функция `makeIncrement(forIncrement: )`, объявленная ранее. Напомню, она возвращает замыкание типа `( )->Int`, которое в данном случае предназначено для увеличения значения на 5. Возвращаемое замыкание записывается в переменную `incrementByFive`, после чего копируется в переменную `copyIncrementByFive`. В результате можно обратиться к одному и тому же замыканию, используя как `copyIncrementByFive`, так и `incrementByFive`

```swift
incrementByFive() // 5
copyIncrementByFive() // 10
incrementByFive() // 15
```

Как видите, какую бы функцию мы ни использовали, происходит модификация одного и того же значения (каждое последующее значение больше предыдущего на 5). Это обусловлено тем, что замыкания передаются по ссылке. 

`#Автозамыкания #autoclosure` – это замыкания, которые автоматически создаются из переданного выражения. Иными словами, может существовать функция, имеющая один или несколько входных параметров, которые при ее вызове передаются как значения, но во внутренней реализации функции используются как самостоятельные замыкания. 

```swift
var arrayOfNames = ["Helga", "Bazil", "Alex"]
func printName(nextName: String ) {
    print(nextName)
}
printName(nextName: arrayOfNames.remove(at: 0))  //Helga
```

При вызове функции `printName(nextName: )` в качестве входного значения ей передается результат вызова метода `remove(at: )` массива arrayOfNames. 
Независимо от того, в какой части функции будет использоваться переданный параметр (или не будет использоваться вовсе), значение, возвращаемое методом `remove(at: )`, будет вычислено в момент вызова функции `printName(nextName: )`. Получается, что передаваемое значение вычисляется независимо от того, нужно ли оно в ходе выполнения функции. 

Отличным решением данной проблемы станет использование ленивых вычислений, то есть таких вычислений, которые будут выполняться лишь в тот момент, когда это понадобится. Для того чтобы реализовать этот подход, можно передавать в функцию `printName(nextName:)` замыкание, которое будет вычисляться в тот момент, когда к нему обратятся 

```swift
func printName(nextName: () -> String) {
    // какой-либо код
    print(nextName())
}
printName(nextName: { arrayOfNames.remove(at: 0) }) // Helga 
```

Для решения этой задачи потребовалось изменить тип входного параметра `nextName` на `()->String` и заключить передаваемый метод `remove(at: )` в фигурные скобки. Теперь внутри реализации функции `printName(nextName: )` к входному параметру `nextName` необходимо обращаться как к самостоятельной функции (с использованием круглых скобок после имени параметра). Таким образом, значение метода `remove(at:)` будет вычислено именно в тот момент, когда оно понадобится, а не в тот момент, когда оно будет передано. Единственным недостатком данного подхода является то, что входной параметр должен быть заключен в фигурные скобки, а это несколько усложняет использование функции и чтение кода. 

С помощью автозамыканий можно использовать положительные стороны обоих рассмотренных примеров: отложить вычисление переданного значения и передавать значение в виде значения (без фигурных скобок). 

Для того чтобы реализовать автозамыкание, требуется, чтобы выполнялись следующие требования: 

- Входной параметр должен иметь функциональный тип.
    В примере, приведенном ранее, параметр `nextName` уже имеет функциональный тип `() -> String`. 
- Функциональный тип не должен определять типы входных параметров. 

В примере типы входных параметров не определены (пустые скобки). 

- Функциональный тип должен определять тип возвращаемого значения. 

В примере тип возвращаемого значения определен как String. 

- Переданное выражение должно возвращать значение того же типа, которое определено в функциональном типе замыкания. 

В примере передаваемая в качестве аргумента функция возвращает значение типа String точно так же, как определено функциональным типом входного параметра 

- Перед функциональным типом необходимо использовать атрибут `@autoclosure, #@autoclosure`
- Передаваемое значение должно указываться без фигурных скобок. 


Перепишем код в соответствии с указанными требованиями

```swift
func printName(nextName: @autoclosure() -> String) {
    print(nextName())
}
printName(nextName: arrayOfNames.remove(at: 0)) // Helga 
```

Теперь метод `remove(at:)` передается в функцию `printName(nextName:)` как обычный аргумент, без использования фигурных скобок, но внутри тела используется как самостоятельная функция. 

Выходящие (сбегающие) замыкания 
По умолчанию все переданные в функцию замыкания имеют ограниченную этой функцией область видимости, то есть если вы решите сохранить замыкание для дальнейшего использования, то встретитесь с определенными трудностями. Другими словами, все переданные в функцию замыкания являются не выходящими за пределы ее тела. Если Swift видит, что область, где замыкание доступно, ограничена, он при первой же возможности удалит его, чтобы освободить и не расходовать оперативную память. 
Для того чтобы позволить замыканию выйти за пределы области видимости функции, необходимо указать атрибут @escaping перед функциональным типом при описании входных параметров функции. Для навигации #@escaping #@escaping
Предположим, что в программе есть специальная переменная, предназначенная для хранения замыканий типа () -> Int, то есть являющаяся коллекцией замыканий 
var arrayOfClosures: [()->Int] = []
Пока еще пустой массив arrayOfClosures может хранить в себе замыкания с функциональным типом () -> Int. Реализуем функцию, добавляющую в этот массив переданные ей в качестве аргументов замыкания 
func addNewClosureInArray(_ newClosure: ()->Int) {
    arrayOfClosures.append(newClosure) // ошибка
}
Xcode сообщит вам об ошибке. И на то есть две причины: 
Замыкание — это тип-ссылка (reference type), то есть оно передается по ссылке, но не копированием. 
Замыкание, которое будет храниться в параметре newClosure, будет иметь ограниченную телом функции область видимости, а значит, не может быть добавлено в глобальную (по отношению к телу функции) переменную arrayOfClosures. 
Для решения этой проблемы необходимо указать, что замыкание, хранящееся в переменной newClosure, является выходящим (сбегающим). Для этого перед описанием функционального типа данного параметра укажите атрибут @escaping, после чего вы сможете передать в функцию addNewClosureInArray(_:) произвольное замыкание 
func addNewClosureInArray(_ newClosure: @escaping ()->Int){
    arrayOfClosures.append(newClosure)
}
addNewClosureInArray({return 100})
addNewClosureInArray{return 1000}
arrayOfClosures[0]() // 100
arrayOfClosures[1]() // 1000
Обратите внимание на то, что в одном случае замыкание передается с круглыми скобками, а в другом — без них. Так как функция addNewClosureInArray(_:) имеет один входной параметр, то допускаются оба варианта. 
Если вы передаете замыкание в виде параметра, то можете использовать модификатор inout вместо @escaping. 

Замыкания 
Используются, когда необходимо сгруппировать блок кода для его передачи или многократного использования. В отличие от функций, замыкания не имеют имени. 
Наиболее часто замыкания используются в качестве обработчика завершения (completion handler). При таком подходе они передаются для обработки результатов выполнения другого действия после его завершения. 
К примеру, вам необходимо организовать функцию для осуществления запросов к серверу в Сети. При этом в зависимости от того, какую информацию вы загружаете, вам потребуется по-разному ее обработать. 
   // загрузка новостей с сервера
   webServer.request(url: "https://swiftme.ru/news", completion:
                           {answerData in
       for item in answerData.items {
           // сохранение новостей в базе данных
           saveToDataBase(item)
       }
}) 
   // загрузка лого с сервера
   webServer.request(url: " https://swiftme.ru/logoImage",
                            completion: {answerData in
       // отображение лого на экране устройства
       showLogo.image(answerData)
   })
Метод webServer.request совершает запрос к серверу, при этом в качестве аргументов ему передается адрес, а также замыкание, которое обрабатывает полученный ответ. 
Таким образом, для любого запроса можно использовать один и тот же метод (request), именно он будет нести ответственность за корректность выполнения данной операции. Но обработка ответа будет осуществляться в соответствии с логикой, переданной в замыкании. 
Еще один пример использования замыкания в качестве completion handler — создание UIAlertAction (кнопка на всплывающем уведомлении в iOS). 
   // создание UIAlertController
   let alert = UIAlertController(
       title: "Alert",
       message: "Volume is \(volume)",
       preferredStyle: .alert
   )

   // создание "кнопки" для UIAlertController, при этом передается замыкание, которое, будет выполнено при нажатии на эту кнопку
   let okAction = UIAlertAction(
       title: "Cancel",
       style: .cancel,
       handler:{ (action) in
           resultLabel.text = "Действие выполнено"
       })
   // размещение кнопки на UIAlertController
   alert.addAction(okAction)
Другим популярным примером использования замыканий являются функции высшего порядка. Это такие функции, которые в качестве аргументов принимают другие функции (или замыкания). 
   // передача замыкания в метод filter
   let array = [1, 2, 3, 4, 5]
   let smallerThanThree = array.filter { $0 < 3 }
   // передача замыкания в метод sorted()
   [1,5,1,6,12].sorted() { $0 < $1 }

---

[К оглавлению](#contents)

###  <a id="chapter14" /> Глава №14. Дополнительные возможности. Методы

Метод #map(_:) позволяет применить переданное в него замыкание для каждого элемента коллекции. В результате его выполнения возвращается новая последовательность, тип элементов которой может отличаться от типа исходных элементов 

let myArray = [2, 4, 5, 7]
var newArray = myArray.map{$0}
newArray // [2, 4, 5, 7]
Метод map(_:) принимает замыкание и применяет его к каждому элементу массива myArray. Переданное замыкание {$0} не производит каких-либо действий над элементами, поэтому результат, содержащийся в переменной newArray, не отличается от исходного. 
В данном примере используется сокращенное имя параметра, а именно $0, эта тема была изучена в главе замыкания. Давайте повторим, каким образом функция map(_:) лишилась круглых скобок и приобрела вид map{$0}. 
Метод map(_:) позволяет передать в него замыкание, которое имеет один входной параметр того же типа, что и элементы обрабатываемой коллекции, а также один выходной параметр. Если не использовать сокращенный синтаксис, то вызов метода будет выглядеть следующим образом: 
    let array = [2, 4, 5, 7]
    var newArray = array.map({
        (value: Int) -> Int in
        return value
    })
Замыкание никак не изменяет входной параметр, просто возвращает его. 
Оптимизируем замыкание: 
-сократим код перед ключевым словом in, так как передаваемое замыкание имеет всего один входной параметр; 
-уберем круглые скобки, так как метод map(_:) имеет один входной параметр; 
-уберем оператор return, так как тело замыкания помещается в одно выражение. Получим следующий код: 
    var newArray = array.map{value in value}
Теперь можно убрать ключевое слово in и заменить value на сокр. имя $0: 
var newArray = array.map{$0} 
Изменим так, чтобы map(_:) возводил каждый элемент в квадрат 
newArray = newArray.map{$0*$0}
newArray // [4, 16, 25, 49]
Как говорилось ранее, тип значений результирующей последовательности может отличаться от типа элементов исходной последовательности. Так, например, количество элементов массивов intArray и boolArray одинаково, но тип элементов различается (Int и Bool соответственно). 
let intArray = [1, 2, 3, 4]
let boolArray = intArray.map{$0 > 2}
boolArray // [false, false, true, true]
Каждый элемент последовательности сравнивается с двойкой, в результате чего возвращается логическое значение. 
Вы можете обрабатывать элементы коллекции с помощью метода map(_:) произвольным образом. Пример создания многомерного массива на основе базового. 
let numbers = [1, 2, 3, 4]
let mapped = numbers.map { Array(repeating: $0, count: $0) }
mapped // [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]
Метод map(_:) позволяет обрабатывать элементы любой коллекции, в том числе и словаря. Перевод расстояния, указанного в милях, в километры. 
let milesToDest = ["Moscow":120.0,"Dubai":50.0,"Paris":70.0]
let kmToDest = milesToDest.map { name,miles in [name:miles * 1.6093] }
kmToDest // [["Dubai": 80.465], ["Paris": 112.651], ["Moscow": 193.116]]

Метод mapValues(_:)
Метод #mapValues(_:) позволяет обработать значения каждого элемента словаря, при этом ключи элементов останутся в исходном состоянии 
let mappedCloseStars = ["Proxima Centauri": 4.24, "Alpha Centauri A": 4.37]
let newCollection = mappedCloseStars.mapValues{ $0+1 }
newCollection  // ["Proxima Centauri": "5.24", "Alpha Centauri A": "5.37]
В итоге вы получаете все тот же словарь, но с обработанными значениями

Метод flatMap(_:)
Метод #flatMap(_:) отличается от map(_:) тем, что всегда возвращает плоский одномерный массив. Так, пример, но с использованием flatMap(_:), вернет одномерный массив 
let numbersArray = [1, 2, 3, 4]
let flatMapped = numbersArray.flatMap { Array(repeating: $0, count: $0) }
flatMapped // [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]
Вся мощь flatMap(_:) проявляется тогда, когда в многомерном массиве требуется найти все попадающие под некоторое условие значения 
let someArray = [[1, 2, 3, 4, 5], [11, 44, 1, 6], [16, 403, 321, 10]]
let filterSomeArray = someArray.flatMap{$0.filter{ $0 % 2 == 0}}
filterSomeArray // [2, 4, 44, 6, 16, 10]

Метод compactMap(_:)
Метод #compactMap(_:) позволяет произвести те же действия, что и map(_:), разница лишь в реакции на ситуацию, когда преобразование не может быть произведено. Пример преобразования массива строковых значений в массив значений типа Int. 
let stringArray = ["1", "2", "3", "four", "5"]
let intFromStringArray = stringArray.map() { Int($0) }
intFromStringArray // [1, 2, 3, nil, 5]
Как видно из значения константы intFromStringArray, при неудачной попытке преобразования String в Int в результирующий массив помещается специальное ключевое слово nil. 
Если воспользоваться методом compactMap(_:), то все неуспешные преобразования будут проигнорированы и исключены из результата 
let arrayWitoutNil = stringArray.compactMap() { Int($0) }
arrayWitoutNil // [1, 2, 3, 5]

Метод filter(_:)
Метод #filter(_:) используется, когда требуется отфильтровать элементы коллекции по определенному правилу 

Показана фильтрация всех целочисленных элементов исходного массива, которые делятся на 2 без остатка, то есть всех четных чисел. 
let numArray = [1, 4, 10, 15]
let even = numArray.filter{ $0 % 2 == 0 }
even // [4, 10]

let starDistanceDict = ["Wolf 359": 7.78, "Alpha Centauri B": 4.37, "Barnard's
Star": 5.96]
let closeStars = starDistanceDict.filter { $0.value < 5.0 }
closeStars // ["Alpha Centauri B": 4.37]

Метод reduce(_: _: )
Метод #reduce(_: _: ) позволяет объединить все элементы коллекции в одно значение в соответствии с переданным замыканием. Помимо самих элементов метод принимает первоначальное значение, которое служит для выполнения операции с первым элементом коллекции. 
Предположим, необходимо определить общее количество имеющихся у вас денег. На вашей карте 210 рублей, а в кошельке 4 купюры разного достоинства. Эта задача легко решается с помощью метода reduce(_: _: ) 
let cash = [10, 50, 100, 500]
let total = cash.reduce(210, +) // 870
Первый аргумент — это начальное значение, второй — замыкание, обрабатывающее каждую пару элементов. Первая операция сложения производится между начальным значением и первым элементом массива cash. Результат этой операции складывается со вторым элементом массива и т. д. Замыкание, производящее операцию, может быть произвольным — главное, чтобы оно обрабатывало операцию для двух входящих параметров 

let multiTotal = cash.reduce(210, { $0 * $1 })
multiTotal // 5250000000
let totalThree = cash.reduce(210, {a,b in a-b})
totalThree // -450
Чтобы было легче запомнить: 
если в reduce в качестве второго аргумента передан оператор, то он просто расставляется между элементами коллекции: 
cash.reduce(210, +) = 210 + 10 + 50 + 100 + 500

Функция zip(_: _: )
Функция #zip(_: _: ) предназначена для формирования последовательности пар значений, каждая из которых составлена из элементов двух базовых по- следовательностей. Другими словами, если у вас есть две последовательности и вам нужно попарно брать их элементы, группировать и складывать в новую последовательность, то эта функция как раз то, что нужно. Сначала вы берете первые элементы каждой последовательности, группируете их, потом берете вторые элементы, и т. д. Пример использования функции zip(_: _: ) 
let collectionOne = [1, 2, 3]
let collectionTwo = [4, 5, 6]
let zipSequence = zip(collectionOne, collectionTwo)
type(of: zipSequence) // Zip2Sequence<Array<Int>, Array<Int>>.Type
// генерация массива из сформированной последовательности
Array(zipSequence) // [(.0 1, .1 4), (.0 2, .1 5), (.0 3, .1 6)]
// генерация словаря на основе последовательности пар значений
let newDictionary = Dictionary(uniqueKeysWithValues: zipSequence)
newDictionary // [1: 4, 3: 6, 2: 5]
Еще один новый тип данных Zip2Sequence<Array<Int>, Array<Int>>. 

Оператор guard для опционалов 
Использование оператора #guard при работе с опционалами. 
Иногда вы хотите проверить условие и продолжать выполнение функции, если условие true. Представьте себе функцию, которая извлекает данные из сети. Эта выборка может потерпеть неудачу, если сеть упадет. Обычный способ инкапсулировать это поведение использует optional, который имеет значение, или не имеет его (nil).
Предположим, что название некоторой геометрической фигуры хранится в константе. Вам потребовалось реализовать механизм вывода на консоль сообщения, содержащего информацию о количестве сторон в данной фигуре. Для реализации задуманного напишем две функции: 
Первая — countSidesOfShape возвращает количество сторон фигуры по ее названию. 
Вторая — maybePrintCountSides выводит необходимое сообщение на консоль. 
Почему лучше написать две функции вместо одной? Так как ваша программа предназначена для работы с геометрическими фигурами, то функция countSidesOfShape может потребоваться вам и для других целей. По этой причине имеет смысл разбить функционал. 
Так как вы не можете заранее предусмотреть все варианты геометрических фигур, то в случае обработки неизвестной фигуры программа должна выводить сообщение о том, что количество сторон неизвестно. Реализуем функцию с именем countSidesOfShape 
func countSidesOfShape(shape: String) -> Int? {
    switch shape {
    case "треугольник":
        return 3;
    case "квадрат":
        return 4;
    case "прямоугольник":
        return 4;
   default: 
   return nil; 
   } 
 } 

Далее реализуем функцию maybePrintCountSides(shape: ), принимающую на вход название фигуры 
func maybePrintSides(shape: String) {
  let sides = calculateNumberOfSides(shape: shape)

  if let sides = sides {
    print("A \(shape) has \(sides) sides.")
  } else {
    print("I don’t know the number of sides for \(shape).")
  }
}
or
func maybePrintCountSides(shape: String) {
    if let sides = countSidesOfShape(shape: shape) {
        print("A \(shape) has \(sides) sides.ны")
    } else {
        print("I don’t know the number of sides for \(shape).")
    }
} 

Для получения количества сторон используется оператор условия if, осуществляющий проверку операции опционального связывания. Логика работы функции состоит в том, что если фигура отсутствует в базе, не имеет смысла выполнять функцию: можно вывести информационное сообщение и досрочно завершить ее работу. Для этого можно использовать оператор раннего выхода guard 
func maybePrintSides(shape: String) {
  guard let sides = calculateNumberOfSides(shape: shape) else {
    print("I don’t know the number of sides for \(shape).")
    return
  }

  print("A \(shape) has \(sides) sides.")
}
Оператор guard проверяет, возможно ли провести операцию опционального связывания, и в случае отрицательного результата выполняет код тела оператора, т.е код в теле оператора guard выполняется только когда false, где с помощью return досрочно завершается работа функции. 
Если опциональное связывание успешно завершается, то тело guard игнорируется и выполняет следующий за ним код. 
С помощью guard код функции стал значительно более читабельным. Особенно это заметно, если код, следующий за оператором, будет занимать больше одной строки. С его помощью вы проверяете возможность получения всех необходимых параметров до того, как перейдете к выполнению кода функции. 

Оператор отложенных действий defer 
Оператор #defer откладывает выполнение определенного в его теле кода до момента выхода из области видимости, в которой он был использован (например, после окончания выполнения функции). 
func someFunction() {
    defer {
        print("action in defer")
    }
    defer { 
        print("another action in defer")
    }
    print("action in function")
}
someFunction()
Консоль: 
action in function
another action in defer
action in defer
Как видно из примера, отложенные действия были выполнены после того, как функция завершила свою работу, и что важно, они выполнялись в обратном порядке: сперва блок последнего оператора defer, затем предпоследнего и т. д. 
Вы можете использовать defer для выполнения любых отложенных действий, очистки и удаления использованных ресурсов, закрытия файлов, логирования и т. д. 

---

[К оглавлению](#contents)

###  <a id="chapter15" /> Глава №15. Ленивые вычисления 

«Ленивый» в Swift звучит как #lazy. Можно сказать, что lazy — синоним производительности. Хорошо оптимизированные программы практически всегда используют ленивые вычисления.
В программировании #ленивыми называются такие элементы, вычисление значений которых откладывается до момента обращения к ним. Таким образом, пока значение не потребуется и не будет использовано, оно будет храниться в виде сырых исходных данных. С помощью ленивых вычислений достигается экономия процессорного времени, то есть компьютер не занимается ненужными в данный момент вычислениями. 
Существует два типа ленивых элементов:

- #lazy-by-name — значение элемента вычисляется при каждом обращении к нему; 
- #lazy-by-need — элемент вычисляется один раз при первом обращении к нему, после чего фиксируется и больше не изменяется. 

Замыкания в ленивых вычислениях 
С помощью замыканий мы можем создавать ленивые конструкции типа lazy-by-name, значение которых высчитывается при каждом обращении к ним
var arrayOfNames = ["Helga", "Bazil", "Alex"]
print(arrayOfNames.count)
let nextName = { arrayOfNames.remove(at: 0) }
arrayOfNames.count //3
nextName()
arrayOfNames.count //2
В константе nextName хранится замыкание, удаляющее первый элемент массива arrayOfNames. Несмотря на то что константа объявлена, а ее значение проинициализировано, количество элементов массива не уменьшается до тех пор, пока не произойдет обращение к хранящемуся в ней замыканию. 
Если пойти дальше, то можно сказать, что любая функция или метод являются lazy-by-name, так как их значение высчитывается при каждом обращении. 

Свойство lazy 
Некоторые конструкции языка Swift (например, массивы и словари) имеют свойство lazy, позволяющее преобразовать их в ленивые. Наиболее часто это происходит, когда существуют цепочки вызова свойств или методов и выделение памяти, и вычисление промежуточных значений является бесполезной тратой ресурсов, так как эти значения никогда не будут использованы. 
Рассмотрим следующий пример: существует массив целых чисел, значения которого непосредственно не используются в работе программы. Вам требуется лишь результат его обработки методом map(_:), и то не в данный момент, а позже 
let baseCollection = [1,2,3,4,5,6]
let myLazyCollection = baseCollection.lazy
type(of:myLazyCollection) // LazySequence<Array<Int>>.Type
let collection = myLazyCollection.map{$0 + 1}
type(of:collection) // LazyMapSequence<Array<Int>, Int>.Type
В результате выполнения возвращается ленивая коллекция. При этом память под отдельный массив целочисленных значений не выделяется, а вычисления метода map(_:) не производятся до тех пор, пока не произойдет обращение к константе collection. 
Вся прелесть такого подхода в том, что вы можете увеличивать цепочки вызовов, но при этом лишнего расхода ресурсов не будет 
let resultCollection = [1,2,3,4,5,6].lazy.map{$0 + 1}.filter{$0 % 2 == 0}
Array(resultCollection) // [2, 4, 6]

---

[К оглавлению](#contents)

### Часть IV ВВЕДЕНИЕ В РАЗРАБОТКУ ПРИЛОЖЕНИЙ 

###  <a id="chapter16" /> Глава №16. Консольные приложения

### «Сумма двух чисел» 

Выберите пункт macOS. 
Выберите шаблон Command Line Tool.
Шаблон Command Line Tool используется при создании приложений, функционирующих в среде командной строки. 
Product Name — название будущего проекта. Введите Swiftme-FirstApp. 
Team — так как мы не планируем размещать программу в магазине приложений, данный пункт оставим без изменений. 
Organization Identifier — идентификатор вашего разработчика. Обычно в качестве идентификатора используют перевернутое доменное имя вашей организации, например com.myorganization. При этом Xcode не связывается с каким-либо доменом в сети, его цель состоит лишь в том, чтобы однозначно идентифицировать разработчика. Должен быть уникальным среди всех разработчиков, размещающих свои приложения в AppStore. 
Bundle Identifier — данная строка генерируется автоматически на основе Organization Identifier и Product Name. Это уникальный идентификатор вашего приложения. Он чувствителен к регистру. 
Language — язык программирования, на котором будет написано ваше приложение. 
Toolbar — панель инструментов. 
Navigator — панель навигации, позволяющая производить навигацию по различным элементам проекта. 
Inspectors — панель настроек, отображающая свойства активного элемента. 
Project editor — редактор и основная рабочая площадка проекта.
Debug area — панель отладки

<img alt="image" src="/Users/flyboroda/Documents/MyGit/Swift-Manual-my-notes/images/view xcode.jpg"/>

<img alt="image" src="/Users/flyboroda/Documents/MyGit/Swift-Manual-my-notes/images/Toolbar view.jpg"/>

Для отображения области отладки (Debug Area) нажать CMD+SHIFT+C или View > Debug Area > Activate Console 

Консольные приложения в macOS запускаются и работают в среде программы Терминал, в папке Программы > Утилиты

У любой программы, написанной на Swift, есть так называемая точка входа, то есть файл с исходным кодом, который будет первым загружен и проанализирован компилятором. Это касается как консольных приложений, так и приложений под iOS. В данном случае точкой входа является файл main.swift, и если вы переименуете его, то при запуске проекта получите сообщение об ошибке. Файлы с расширением .swift содержат исходный код

Разрабатываемая программа должна запрашивать у пользователя два значения, производить их сложение и выводить результат на консоль. Для получения значений, вводимых с клавиатуры, в консольных приложениях служит функция #readLine(). Она ожидает ввода данных с клавиатуры с последующим нажатием кнопки Enter, после чего возвращает значение типа String? (опциональный строковый тип данных). 
print("Введите первое значение")
// получение первого значения
var a = readLine()
print("Введите второе значение")
// получение второго значения
var b = readLine()
С помощью данного кода у пользователя будут запрашивать значения параметров a и b 
Следующей задачей станет подсчет суммы введенных значений. Для этого требуется создать специальную функцию sum(_: _: ), принимающую на вход два значения типа String? в качестве операндов операции сложения. Немного оптимизируем структуру, написав sum(_: _: ) в отдельном файле 
Добавим в проект новый файл: 

- Правой кнопкой мыши щелкните на папке SwiftmeFirstApp в Navigator. 
- В появившемся меню выберите пункт New File. 
- В появившемся окне выберите Swift File 

В данном файле мы реализуем функцию sum(_: _: ), предназначенную для сложения двух чисел. Входные параметры функции будут иметь тип String? (соответствует типу возвращаемого функцией readLine() значения), а внутри ее реализации перед операцией сложения — преобразовываться к Int. 
На панели Toolbar нажмите кнопку Library  
В появившемся окне нажмите кнопку Show the Snippets Library   
C помощью поля поиска отфильтруйте сниппеты по слову func. 
Среди элементов щелкните на Function Statement. 

Выделив поле name в шаблоне, вы сможете ввести имя функции, а с помощью клавиши Tab на клавиатуре — перескакивать к следующему требуемому полю. Используя созданный шаблон, напишите функцию sum(_:  _:  ) 
func sum(_ a: String?, _ b: String?) -> Int {
    return Int(a!)! + Int(b!)!
}
Значение, переданное на вход функции Int(_:), не должно быть опциональным. С этим связан знак принудительного извлечения опционального значения внутри Int(_:), то есть первый знак восклицания. 
Оператор сложения внутри функции sum(_:_:) может производить операцию сложения только с неопциональными значениями, в то время как функция Int(_:) в качестве результата своей работы возвращает значение типа Int?. Именно по этой причине ставится второй восклицательный знак. 
Несмотря на то что функция sum(_: _: ) описана в файле func.swift, она может использоваться и в других файлах проекта. 
Добавьте в конец файла main.swift код 
let result = sum(a, b)
print("Результат сложения - \(result)")

---

[К оглавлению](#contents)

###  <a id="chapter17" /> Глава №17. Консольная игра «Угадай число» 

Компьютер загадывает целое число в диапазоне от 1 до 50, а игрок пытается угадать его за минимальное количество ходов. После каждой попытки приложение должно сообщать, как введенное число соотносится с загаданным — больше, меньше или равно ему. 
Наша будущая игра будет функционировать по следующему алгоритму: 
Генерация случайного числа -> 
Запрос числа у пользователя -> 
Сопоставление сгенерированного числа с запрошенным ->
Вывод результата сопоставления ->
Если числа одинаковы, то работа программы завершается ->
Если числа различны, то происходит переход к шагу 2. 
В файле main.swift реализуем механизм генерации случайного числа 
// генерация случайного числа
let randomNumber = UInt8.random(in: 1...250)
    Константа randomNumber содержит случайно сгенерированное число. 
Несколько слов об оптимизации приложения. В общем случае любая оптимизация — это поиск компромисса, обычно между памятью и процессорным временем устройства. Обратите внимание, что в качестве типа данных константы randomNumber используется UInt8. Если не определить тип данных самостоятельно, то Swift автоматически определит его как Int, а это 64 бита памяти вместо 8 бит. Да, конечно, в данном случае экономия не имеет какой-либо практической пользы, но я настоятельно советую вам привыкать к процессу оптимизации. Тем не менее порой вы можете пойти на некоторые траты ресурсов в угоду читабельности кода, но я советую вам думать об оптимизации при написании любого кода. 
Шаги 2–6 описанного выше алгоритма — это цикл. Ваша программа не должна завершать работу до тех пор, пока число не будет отгадано. Для реализации этого условия лучше использовать конструкцию repeat while
import Foundation
// генерация случайного числа
let randomNumber = UInt8.random(in: 1...250)
print("Компьютер случайным образом загадал число. Вам требуется отгадать его.")
// в переменную будет записываться число с консоли
var myNumber: String?
// цикл с постпроверкой условия
repeat {
    print("Введите ваш вариант и нажмите Enter")
    // получение значения с клавиатуры пользователя
    myNumber = readLine()
    // сравнение введенного и сгенерированного чисел
    if (UInt8(myNumber!) == randomNumber) {
        print("Вы угадали!")
    } else if (UInt8(myNumber!)! < randomNumber) {
        print("Ваш вариант меньше загаданного числа")
    } else if (UInt8(myNumber!)! > randomNumber) {
        print("Ваш вариант больше загаданного числа")
    }
} while randomNumber != UInt8(myNumber!)

<img alt="image" src="/Users/flyboroda/Documents/MyGit/Swift-Manual-my-notes/images/Консольная игра Угадай число.jpg"/>

Устраняем ошибки приложения 
Выделим основные проблемы программы: 
-Аварийное завершение работы приложения при вводе нецифровых символов. 
-Аварийное завершение работы приложения при вводе числа больше 255 (верхняя граница типа UInt8).
-При доступе к значению опционала используется принудительное извлечение значения там, где это может привести к аварийному завершению. 
-Многократное приведение к типу UInt8. 
Решение:

```swift
print("Компьютер случайным образом загадал число. Вам требуется отгадать его.")

// Случайное число
let randomNumber = UInt8.random(in: 1...250)
print("Введите вариант числа от 1 до 250 и нажмите Enter")

// флаг-указатель на победу
var isWin = false
repeat {
          // попытка преобразования введенного значения к UInt8
          guard let userNumber = UInt8(readLine() ?? "") else {
              print("Вы ввели некорректное число. Попробуйте снова")
              continue 
          } 

          // проверка введенного числа
          if userNumber < randomNumber{
          print("Ваш вариант меньше загаданного числа")
          } else if userNumber > randomNumber {
          print("Ваш вариант больше загаданного числа")
          } else {
          print("Вы угадали")
          isWin = true 
          } 
} while !isWin
```

---

[К оглавлению](#contents)

Часть V. НЕТРИВИАЛЬНЫЕ ВОЗМОЖНОСТИ SWIFT. 

###  <a id="chapter18" /> Глава №18. Введение в объектно-ориентированное и протокол-ориентированное программирование 



---

[К оглавлению](#contents)

###  <a id="chapter19" /> Глава №19. 



---

[К оглавлению](#contents)

###  <a id="chapter20" /> Глава №20. 



---

[К оглавлению](#contents)

###  <a id="chapter21" /> Глава №21. 



---

[К оглавлению](#contents)

###  <a id="chapter22" /> Глава №22. 



---

[К оглавлению](#contents)

###  <a id="chapter23" /> Глава №23. 



---

[К оглавлению](#contents)

###  <a id="chapter24" /> Глава №24. 



---

[К оглавлению](#contents)

###  <a id="chapter25" /> Глава №25. 



---

[К оглавлению](#contents)

###  <a id="chapter26" /> Глава №26. 



---

[К оглавлению](#contents)

###  <a id="chapter27" /> Глава №27. 