### Swift Manual
Конспект из разных источников

<a id="contents" />Оглавление

- [Глава №1. Основные понятия. Начало работы с Xcode.](#chapter1)
- [Глава  №2. Фундаментальные типы данных.](#chapter2)
- [Глава  №3. . ](#chapter3)
- [Глава  №4. . ](#chapter4)
- [Глава  №5. . ](#chapter5)
- [Глава  №6. . ](#chapter6)
- [Глава  №7. . ](#chapter7)
- [Глава  №8. . ](#chapter8)
- [Глава  №9. . ](#chapter9)
- [Глава  №10. . ](#chapter10)
- [Глава  №11. . ](#chapter11)
- [Глава  №12. . ](#chapter12)
- [Глава  №13. . ](#chapter13)
- [Глава  №14. . ](#chapter14)
- [Глава  №15. . ](#chapter15)
- [Глава  №16. . ](#chapter16)
- [Глава  №17. . ](#chapter17)
- [Глава  №18. . ](#chapter18)
- [Глава  №19. . ](#chapter19)
- [Глава  №20. . ](#chapter20)
- [Глава  №21. . ](#chapter21)
- [Глава  №22. . ](#chapter22)
- [Глава  №23. . ](#chapter23)
- [Глава  №24. . ](#chapter24)
- [Глава  №25. . ](#chapter25)
- [Глава  №26. . ](#chapter26)
- [Глава  №27. . ](#chapter27)

[К оглавлению](#contents)
###  <a id="chapter1" /> Глава №1. Основные понятия. Начало работы с Xcode

***[Help > Xcode Help](https://help.apple.com/xcode/mac/11.0/index.html)***

2 июня 2014 года компания представила язык программирования Swift. 

http://online.swiftplayground.run/ онлайн-редактор со встроенным компилятором Swift-кода 

Swift – это тип безопасный язык type-safe, означает, что язык помогает вам четко понимать, с какими типами значений может работать ваш код.

`Control-Command-F` – full-screen 
`Control-Left Arrow` and `Control-Right Arrow` перемещаться между приложениями

In December 2015, Apple released the Swift language
Консоль – это инструмент для ввода текста и отображения для администрирования системы

<img alt="image" src="images/Hello, World! В Terminal.jpg"/>

You can turn on line numbers on the left side of the source editor by clicking Xcode ▸ Preferences... ▸ Text Editing ▸ Line Numbers. 
View ▸ Debug Area ▸ Show Debug Area

IDE (integrated development environment) интегрированная среда разработки

Push notification – это сообщение, отправленное службой Push-уведомлений Apple (APNs) приложению, которое не работает на переднем плане. Уведомление может отображаться как уведомление пользователя или доставляться в автоматическом режиме, позволяя получающему приложению временно проснуться для обработки новых данных.

<img alt="image" src="images/Xcode interfaces 1.jpg"/>

<img alt="image" src="images/Xcode interfaces 2.jpg"/>

<img alt="image" src="images/Xcode interfaces 3.jpg"/>

<img alt="image" src="images/Xcode interfaces 4.jpg"/>

***Playground*** — это интерактивная среда разработки, своеобразная «песочница», или «игровая площадка», где вы можете тестировать создаваемый вами код и видеть результат его исполнения в режиме реального времени. 

Для создания нового playground-проекта выберите пункт главного меню `File > New > Playground`. Далее вам необходимо выбрать тип Blank, который содержит минимальное количество кода. 

`Option (Alt)` и щелкнуть на любом объекте в области кода, то появится вспомогательное окно, в котором можно узнать тип объекта, а также имя файла, где он расположен 
`.xcodeproj` file, which includes all the settings for your project and its targets. 

Проект, с которым вы работаете, имеет только одну цель: приложение iOS. В файле проекта вы можете изменить все детали конкретной цели. Например, в разделе «Deployment Info» вы можете указать, какая версия iOS ваш код должен поддерживать, изменять, какие устройства ваше приложение поддерживает для запуска или показать / скрыть строку состояния.

При выборе Signing & Capabilities (подписания и возможностей) в верхней части панели вы можете настроить подпись кода, что является требованием для развертывания устройств или в App Store. С этого экрана вы также можете включить различные функции в выбранной цели. Например, если ваша заявка должна принимать push-уведомления, вы можете добавить возможности Push-уведомления (Push Notifications capability), и Xсode настраивает все необходимое для вашего приложения для получения уведомлений из службы Apple Push Notifications. Вы можете добавить конфигурации возможностей, нажав кнопку Capability button +.

Некоторые возможности имеют параметры конфигурации, которые вы можете раскрывать, нажав треугольник рядом с ними

`.storyboard` files уникальны для интерфейса построителя. Они содержат информацию о дизайне каждой сцены в вашем приложении, а также как один экран переходит в другой. 

`.xcassets` file represents an asset catalog. In an asset catalog, you can manage many different kinds of assets. This includes your app's icon, images, color definitions, and другие формы данных, которые должны быть в комплекте с вашим приложением. Каталог активов (asset catalog) также позволяет указывать варианты своих активов на основе настроек и возможностей устройств, таких как светлый и темный внешний вид, настроек доступности для высоких и низких контрастных и аппаратных различий от экрана.

`info.plist` содержит список свойств и настроек для вашего приложения. Xcode предоставляет спец. интерфейс для редактирования этого файла

```bash
Command-B - построить проект.
Command-R - построить и запустить проект.
Command -. - Остановить сборку или запуск
Command - / - Переключить комментарии к выбранным строкам кода
Command - [- Сдвинуть выделенный код влево
Command -] - сдвинуть выделенный код вправо
Control-I - изменить выделение выбранного кода (выравнивает код)
Command-0 - показать и скрыть навигатор.
Option-Command-0 - показать и скрыть инспектор.
```

Чтобы узнать о сочетаниях клавиш, `Xcode> Preferences> Key Bindings`

---

### Какими должны быть размеры изображений в 1x, 2x и 3x в Xcode?
Вам нужно 3 вида изображений в ресурсах изображений, потому что с точки зрения масштабирования или пикселей cуществует 3 вида устройств Apple (iPhone и iPad), которые

-Обычное устройство, которое соответствует 1 pixel = 1 point #1x (более старые устройства iPhone и iPad)

-Устройство Retina, которое соответствует 4 pixels(2 x 2) = 1 point #2x (iPhone 4+)

-Retina iPhone 6 и iPad, которые соответствуют 9 pixels (3 x 3) = 1 point #3x (iPhone 6+)

Таким образом, для предоставления одного и того же изображения в 3 масштабах iOS решает, какое изображение показывать для каких устройств. 

<img alt="image" src="images/размеры изображений в 1x, 2x и 3x .jpg"/>

Важно при добавлении изображений в xcode верное именование, чтобы он сразу расставил их по нужным местам, например `Icon-20@2x.png` 

Вот размеры под iphone https://www.paintcodeapp.com/news 

App Icon Generator	https://appicon.co/#image-sets 

<img alt="image" src="images/App Icon Generator .jpg"/>

Копирование в xcode, зажимаем option и перетаскиваем копию объекта

<img alt="image" src="images/отображение элементов.jpg"/>

Exception тоже самое, что и Error.
Deprecated code – неподдверживаемый код.
- Warnings. Writing code that never gets executed (никогда не выполняется)
- Creating a variable that never changes (никогда не меняется)
- Using code that’s out of date (который устарел) or also known as deprecated code (устаревший код)

***Breakpoint***. In the debug area, show the variables view to inspect the current values. Вы увидите паузу программы в точке останова. Это хорошо. В области отладки отобразите представление переменных для проверки текущих значений (кнопка находится в правом нижнем углу). Поскольку строка с точкой останова еще не была выполнена, имена не содержат значений.

Отсюда вы можете использовать кнопки управления шагом в верхней части области отладки, чтобы медленно продолжить выполнение кода:

***Continue*** – возобновляет выполнение кода до тех пор, пока не будет достигнута следующая breakpoint. Если вы нажмете эту кнопку сейчас, код выйдет из строя, так как нет других breakpoint перед третьим name.removeFirst ().

***Step over*** – Перешагнуть – выполняет выбранную строку и приостанавливает выполнение на следующей строке.

***Step into***  –  Шаг внутрь – если щелкнуть строку с вызовом функции, переход к первой строке функции, затем снова останавливает выполнение.

***Step out*** – Выйти – выполняет все оставшиеся строки в вызове функции и приостанавливает выполнение на строке после функции

<img alt="image" src="images/пример error.jpg"/>

При исправлении кода, также в этой панели будет положительный результат и все отображения операций. Благодаря breakpoint можно исправлять баги и решать проблемы в app при вылетах или ошибках.

***Действие или IBAction*** соединяет метод в исходном коде и элемент управления в Interface Builder, позволяющий запускать определенный код при взаимодействии пользователя с элементами управления приложения. Например, определенный метод может быть связан с действием, таким как нажатие кнопки или изменение переключателя, taps.

***Холст or Canvas*** относится к фону раскадровки, где вы добавляете и упорядочиваете сцены и элементы пользовательского интерфейса (UI)

***Выход или IBOutlet*** соединяет переменную в исходном коде с объектом в раскадровке, позволяя коду получать информацию от объекта и вносить изменения по мере запуска приложения.

***Файл XIB*** представляет собой одну сцену или представление в iOS и может быть открыт и изменен в Interface Builder. Файлы XIB были более популярны до появления раскадровки в iOS 5.

Контроллер вида (view controller) управляет набором представлений и координирует поток информации между моделью данных приложения и представлениями, отображающими данные.

Контроллер начального вида – это первая сцена, которая будет просмотрена пользователем при запуске приложения. В раскадровках контроллер начального вида отмечен серой ***стрелкой***, но вы также можете установить контроллер начального вида в Attributes inspector для отдельной сцены.
Вы можете изменить view controller, переместив точку входа (стрелка в правой стороне) слева от нужного контроллера просмотра. В настоящее время в этом проекте Main.Storyboard имеет только один контроллер просмотра, поэтому вы не сможете его изменить.

***Identity inspector*** – позволяет редактировать свойства, связанные с идентичностью объекта, например, к какому классу он принадлежит. В этом примере кнопка принадлежит к классу UIButton. Если вы определили пользовательский класс кнопки в другом месте, вы можете использовать инспектор идентификатора, чтобы изменить класс кнопки, которую вы только что добавили. 

***Attributes inspector*** предоставляет список регулируемых визуальных свойств для выбранного элемента. В случае UIButton вы можете изменить такие атрибуты, как текст кнопки, цвет текста, фона и выравнивание. 

***Size inspector*** – позволяет настроить размер и положение выбранного элемента внутри сцены. Вы будете использовать поля x и y - где вверху слева экрана соответствует (0,0) - изменять положение. Значение x становится больше, когда вы перемещаете элемент дальше вправо, а y становится больше, когда вы двигаетесь вниз по экрану. Для UIButton инспектор размера включает в себя дополнительные поля для настройки прокладки вокруг заголовка или изображения кнопки.

***Connections inspector*** перечисляет все функции и имена переменных, относящиеся к объекту, и как они связаны

Если xcode тормозит или выполнение кода зависло, то:

- Завершите процесс зависшего симулятора. Для этого откройте `Программы > Утилиты > Мониторинг системы`, после чего найдите и завершите процесс `com.apple.CoreSimulator. CoreSimulatorService.` 

- Измените платформу playground-проекта с iOS на macOS. Для этого нажмите кнопку Hide or Show the Inspector, расположенную в правом верхнем углу, и в поле Platform выберите необходимый пункт. В этом случае вам надо внести правки в первую строку в редакторе кода: заменить import UIKit на import Foundation, так как библиотека UIKit доступна исключительно в мобильных операционных системах iOS и iPadOS. 

---

### Outlets and Actions
Нужен способ связки ваших визуальных элементов с кодом, чтобы их можно было отрегулировать во время выполнения или когда приложение уже запущено. Эта ссылка из Interface Builder к коду называется ***outlet***. Когда у вас есть объект, c которым вы хотите, чтобы пользователь мог взаимодействовать, вы создаете ***action***– ссылку на кусок кода, который будет выполнен при взаимодействия с ним пользователя (нажатие, переключение) 

***Creating an #Outlet or #Action***.
Control-click the button in the storyboard, and start dragging toward the assistant editor pane that contains the ViewController class definition. As you drag the pointer into the code, you see a blue line.

<img alt="image" src="images/Creating an Outlet or Action1.jpg"/>

<img alt="image" src="images/Creating an Outlet or Action2.jpg"/>

<img alt="image" src="images/Creating an Outlet or Action3.jpg"/>

Имя которое мы даем выше в появляющимся окне, сохраняется внутри кода и связывается с объектом, все это под капотом, поэтому нельзя просто так изменять имя в коде, будет ошибка. Необходимо удалить привязку, для этого нажимаем правую клавишу (тап с 2 пальцами) и удаляем привязку.

<img alt="image" src="images/Creating an Outlet or Action4.jpg"/>

Или безопасно переименовать из меню

<img alt="image" src="images/Rename an Outlet or Action1.jpg"/>

Все свойства из Interface Builder можно применить программно, явно прописав их в коде, есть свойства которых нет в Interface Builder и они указываются только программно. Например:

`UIScrollView` has a contentSize property that does not have a matching option in the Attributes inspector.
`scrollView.contentSize = CGSize(width: 100, height: 100)`

### Основные понятия работы компьютера
Все элементы компьютера в общем случае можно разделить на три основных функциональных уровня аппаратный, операционной системы и программный. 

Аппаратный уровень представлен физическим оборудованием компьютера. Это та основа, на которой базируются остальные уровни. Самые важные элементы аппаратного уровня — это центральный процессор (CPU, Central Processing Unit) и оперативная память. 

Данные, с которыми работает процессор, хранятся во временном хранилище — оперативной памяти.

Оперативная память — это основное средство хранения данных, используемое программами в ходе их функционирования. Память компьютера состоит из миллионов отдельных ячеек, каждая из которых может хранить небольшой объем информацию. Каждая ячейка имеет уникальный адрес, по которому ее можно найти в памяти. Но размер ячейки не позволяет хранить в ней большое количество данных, по этой причине ячейки логически объединяются в хранилища данных.

Хранилище может объединять произвольное количество ячеек, его размер определяется количеством записанной информации и при необходимости может изменяться. Как и ячейка памяти, хранилище имеет уникальный адрес, по которому может быть получено хранящееся в нем значение (обычно он соответствует адресу первой входящей в него ячейки) 

<img alt="image" src="images/оперативная память.jpg"/>

Оперативная память хранит нужные данные так долго, как этого требует ваше приложение (ограничиваясь лишь временем, пока оно запущено). Для постоянного (долговременного) хранения информации используются др. элементы аппаратного уровня, например HDD или SSD. 

Операционная система (ОС) — это посредник между вашей программой и аппаратной частью. 

Программный уровень — это все программы, которые работают на вашем компьютере в среде операционной системы. 

<img alt="image" src="images/уровни памяти и взаимодействия.jpg"/>

Хранилище данных это виртуальный объект со свойствами: 
- записанное значение; 
- идентификатор (имя); 
- тип информации, для хранения которой предназначено хранилище (числовой, строковый и др.). 

Практически весь процесс программирования заключается в том, чтобы создавать (объявлять) объекты, задавать (инициализировать или рисваивать) им значения, получать эти значения из памяти и производить с ними операции. 

Объявление — это создание нового объекта (хранилища данных). 

Инициализация — это присвоение значения объекту. 

```bash
СоздатьХранилище с именем value1 и значением 23
СоздатьХранилище с именем value2 и значением 145
СоздатьХранилище с именем result и значением value1 * value2 // 3335
```

<img alt="image" src="images/СоздатьХранилище с именами.jpg"/>

Хранилища данных могут содержать в себе не только цифры, но и другие виды информации (текстовую, графическую, логическую и др.). Виды информации в программировании называются типами данных. При объявлении хранилища ему всегда назначается тип данных, определяющий, какие именно данные будут храниться в нем. 

***Выражение*** — команда, выполняющая одну или несколько операций. Выражение может состоять из множества операторов и операндов. 

***Оператор*** — это минимальная независимая функциональная единица (символ, слово или группа слов), выполняющая определенную операцию. 

***Операнд*** — это значение, с которым оператор производит операцию.

```swift
import UIKit
var str = "Hello, playground"
```

С помощью ключевого слова (оператора) var объявляется новое хранилище данных с именем str. Этому хранилищу инициализируется (присваивается) текстовое значение Hello, playground. Этот процесс и называется инициализацией значения с помощью оператора `= (присваивания)`. 

---

### Классификация операторов operators
The values that #operators affect are operands. In the expression 1 + 2, the + symbol is a binary operator and its two operands are the values 1 and 2.

Простые операторы, выполняющие операции со значениями (операндами). В их состав входят унарные и бинарные операторы. 

-Unary operators operate on a single target (`-a`). Unary prefix operators (`!b`), and unary postfix operators (`c!`).

```swift
let three = 3 
let minusThree = -three // minusThree equals -3 
let plusThree = -minusThree // plusThree equals 3, or "minus minus three"
```
***Унарные операторы*** выполняют операцию с одним операндом. Они могут находиться перед операндом (префиксные) или после него (постфиксные). 

Оператор `var`, с помощью которого объявляется хранилище данных, или оператор минус (`-a`), с помощью которого создаются отрицательные числа, являются унарными префиксными. 

***Постфиксные операторы***, например, многоточие (`...`) в выражении `1...` указывает на все целые числа после единицы. ***Префиксные операторы*** `…5`

***Бинарные операторы*** выполняют операцию с двумя операндами. Оператор, который располагается между операндами, называется ***инфиксным***. Binary operators operate on two targets (`2 + 3`)

***Оператор инициализации*** (`=`) и ***оператор сложения*** (`+`) являются бинарными инфиксными, так как использует в работе два операнда и находятся между ними (`value1 = 12 или 34+12`). 

***Структурные операторы*** влияют на ход выполнения программы. Например, останавливают выполнение программы при определенных условиях или указывают программе, какой блок кода должен быть выполнен при определенных условиях. -***Ternary operators operate*** on three targets. the ternary conditional operator (`a ? b : c`).

***Оператор инициализации (присваивания)*** (`=`) — это бинарный оператор. Он используется в типовом выражении `a = b`, присваивая хранилищу данных с именем `a` значение хранилища данных с именем `b`. В листинге объекту `str` инициализируется текстовое значение Hello, playground 

Assignment operator – оператор присваивания = 
initializes or updates the value of a with the value

```swift
let b = 10 
var a = 5 
a = b     // a is now equal to 10 
```
Если правая часть присваивания представляет собой кортеж с несколькими значениями, его элементы можно разложить на несколько констант или переменных одновременно:

```swift
let (x, y) = (1, 2)       // x is equal to 1, and y is equal to 2
```

***переменные***, объявляемые с помощью ключевого слова `var`;

***константы***, объявляемые с помощью ключевого слова `let`. 

---

### Naming data. Variables
When you know you’ll need to change some data, you should use a variable

```swift
var variableNumber: Int = 42
variableNumber = 0
variableNumber = 1_000_000
```

Переменные для хранения значений, которые могут изменяться в ходе выполнения кода. 

***Переменная*** — это хранилище данных, значение которого может быть многократно изменено разработчиком в процессе работы программы. 

   `var имяПеременной = значениеПеременной`

Имя несет в себе type annotation, которая указывает, к какому типу данных относится это имя, например, текст, числа или дата

---

### Constants
```swift
let number: Int = 10
var anotherNumber = number
anotherNumber = 30 + number
```

This declares a constant called number which is of type Int. Then it sets the value of the constant to the number 10.

Константа присвоить значение можно только один раз. Все последующие попытки изменить его вызовут ошибку. 

Константы объявляются с помощью оператора let. 
   `let имяКонстанты = значениеКонстанты`

**Константы** – базовое средство оптимизации используемых мощностей. Поэтому если инициализированное значение не планируется изменять, программисты всегда должны использовать константы. Константы для хранения значений, которые не должны и не будут изменяться в ходе выполнения кода. 

Имя пользователя. 
  `let username = "Artem"`

Устройство, на котором запущено приложение. 
  `let phoneModel = "iPhone 15"`

Объявление нескольких параметров в одном выражении 
При объявлении нескольких параметров вы можете использовать один оператор – `var` или `let` и через запятую попарно указать их имена и инициализируемые значения.

```swift
let friend1 = "John", friend2 = "Helga"
var age1 = 54, age2 = 25
var x = 0.0, y = 0.0, z = 0.0
```

---
### Type inference – Вывод типа
Вывод типа. Swift использует вывод типов для определения типа объекта на основе доступной информации, даже если имя типа явно не выражено словами в коде. Например, если объявлена функция, возвращающая `String`, например `func answer() -> String`, и константа инициализируется результатом `func answer`, например `let nextIdea = answer()`, тип `nextIdea` будет выведен как `String`.

Вывод типа – когда swift сам понимает какой тип данных вы назначили в `var` or `let`, т.е без явного указания. Неявное объявление. Вам не нужно объявлять константы или переменные как Bool/Int/Double и тп, если вы устанавливаете для них значение сразу после их создания. Вывод типа помогает сделать код Swift более кратким и читаемым, когда он инициализирует константы или переменные другими значениями, тип которых уже известен.

Как только вы назначаете значение `let` или `var`, тип устанавливается и не может быть изменен. Значение `var` может измениться, но не его **тип**.

***Нельзя поменять тип присвоенного значения, можно переконвертировать в другое, но не изменить, так как он уже назначен.***

Три примера для использования type annotation:

1. When you create a constant or variable but не назначаете it a value.
```swift
let firstName: String
//... 
firstName = “Layne”
```

2. When you create a constant or variable that could be предполагать as more than one type.
```swift
let middleInitial: Character = “J”
// “J” would be inferred as a `String`, but we want a `Character` 
 
var remainingDistance: Double = 30
// `30` would be inferred as an `Int`, but the variable should support decimal numbers for accuracy as the number decreases. 
```

3. When you write your own type definition.
```swift
struct Car {
  var make: String
  var model: String
  var year: Int
}
```

Чтобы узнать тип нажимаем `Option` и кликаем на имя.

This uses a new keyword you haven’t seen before, `as`. It also performs a type conversion. Это также выполняет преобразование типа явно в `Double`

```swift
let actuallyDouble = 3 as Double // тип Double
```

---
### Инициализация копированием 
Инициализацию значения любых параметров (переменных и констант) можно проводить, указывая в правой части выражения не только конкретное значение, но и имя другого параметра

```swift
let myAge = 40
var yourAge = myAge
yourAge
```

Таким образом вы создаете ***копию*** исходного значения, то есть в результате операции будет объявлена константа и переменная с двумя независимыми значениями. Изменение одного из них не повлияет на другое. 

Тип данных параметра, который обеспечивает передачу значения **копированием, называется #value type** (значимый тип, или тип-значение). 

Помимо передачи значения копированием, существует **передача ссылки на значение**, когда несколько параметров содержат в себе **ссылку на одно и то же значение, хранящееся в памяти**. Тип данных, который обеспечивает передачу значения **ссылкой, называется #reference type (ссылочный тип, или тип-ссылка)**. При этом изменение значения через любой из параметров отразится и на всех копиях-ссылках. Другими словами, параметры ссылочного типа устанавливают для ячейки памяти несколько имен.

**Кодовые сниппеты** – это шаблоны, позволяющие быстро создавать типовые конструкции. 

Библиотеку кодовых сниппетов можно открыть с помощью кнопки с изображением символа `+`, расположенной в верхней части `Xcode Playground`.

---

### Область видимости (scope) 

У каждого объекта есть область его применения, или, другими словами, область видимости #scope, которая определяет, где именно данный объект может быть использован. Например, область видимости объекта может быть ограничена файлом или отдельным блоком кода. 

По области видимости объекты можно разделить на два вида: 

**Глобальные** — это объекты, доступные в любой точке программы. 

**Локальные** — это объекты, доступные в пределах родительского объекта. 

<img alt="image" src="images/Область видимости.jpg"/>

Объекты `User` и `Friend` объявлены непосредственно в корне программы. Такие объекты называются глобальными, они доступны в любой точке программного кода. 

Каждый из глобальных объектов из примера выше содержит внутренние, локальные по отношению к нему, объекты: 
- В составе `User` есть объект `login`; 
- В составе `Friend` есть два объекта: `name` и `surname`. 
Локальные объекты доступны только в пределах своего контекста, то есть родительского объекта. 

---
### Комментарии и Markdown
#Markdown-комментарии должны начинаться с двойной косой черты и двоеточия (`//:`), после которых следует текст комментария. 

Включить форматирование комментариев, при котором все markdown-комментарии отобразятся в красивом и удобном для чтения стиле, можно, выбрав в меню Xcode пункт `Editor > Show Rendered Markup`. 

Вернуть markdown-комментарии к прежнему неформатированному виду можно, выбрав в меню пункт `Editor > Show Raw Markup`.

```swift 
// This is also a comment.
// Over multiple lines

/* This is also a comment.
   Over many..
   many...
   many lines. */
```

<img alt="image" src="images/Markdown1.jpg"/>

<img alt="image" src="images/Markdown2.jpg"/>

Переданное в функцию значение используется внутри нее и в ее пределах называется входным параметром. 

Не стоит путать понятия аргумент функции и входной параметр.

***Аргумент функции*** – то, что передается в функцию в скобках при ее вызове

***Входной параметр*** – то, что используется внутри функции. 

По сути, это может быть одно и то же значение, но во время вызова функции — это аргумент, а в теле функции — это параметр. 

Каждая функция имеет сигнатуру, то есть краткое описание. Сигнатура содержит информацию об имени функции, ее аргументах и возвращаемом функцией значении. Она может быть в одной из трех форм: 

1. Полная, с указанием типов данных:  
     `someFunction(a:String, b: String) -> String`
2. Стандартная, без указания типов данных:  
     `someFunction(a: b:)`
3. Краткая, с указанием только имени функции:  
     `someFunction`

Если функция принимает входные аргументы, то это отражается в сигнатуре. 

`print(_:)` описывает функцию с именем print, которая принимает один входной безымянный аргумент. 

`anotherFunction(name:)` описывает функцию с именем anotherFunction, которая принимает один аргумент с именем name. 

`someFunction(a:b:)` описывает функцию с именем someFunction, которая имеет два вход- ных аргумента с именами a и b. 

`myFunction()` описывает функцию с именем myFunction, которая не имеет аргументов. может служить функция print(_:)). 

Таким образом сигнатура кратко описывает не только название функции, но и ее аргументы. 
Если аргумент не имеет имени, то вместо его имени ставится нижнее подчеркивание ` _ `

Таким образом, сигнатура `goodFunction(_: text:)` указывает на функцию с именем goodFunction, которой нужны два аргумента: первый не имеет имени, а второй должен быть передан с именем text. 

Пример вызова функции `goodFunction (_: text:)`

`goodFunction(21, text: "Hello!")`

Cуществует возможность объединить вывод текстовой информации со значением некоторого параметра (или параметров). Для этого используется символ обратной косой черты (слеша) ` \(…)`, после которого в круглых скобках нужно указать имя выводимого параметра

```python
let bar = "Swift"
print("Я изучаю \(bar)") // Я изучаю Swift
```

---
[К оглавлению](#contents)
###  <a id="chapter2" /> Глава №2. Фундаментальные типы данных 

Тип данных определяет вид информации, которая может храниться в параметре. Например, параметр со строковым типом данных сможет хранить только строковые значения. 

Если точнее, то ***тип данных*** — это множество всех возможных значений, а также операций над ними. Например, если у параметра числовой тип данных, то ему может быть присвоено числовое значение, с которым можно проводить математические операции (сложение, вычитание, деление, умножение и т. д.). Воспринимайте типы данных как абстракции, шаблоны, на основе которых создаются конкретные значения. Например, на основе типа данных «целое число» можно создать значения 2, 17, 36. Сам по себе тип «целое число» лишь выделяет диапазон возможных значений, но не несет никакой конкретики, никакой точной величины. 
Если мы говорим о какой-то типовой фигуре (о квадрате или о шаре в широком смысле), то говорим о типе данных; если мы говорим о конкретной фигуре (этот большой зеленый куб), расположенной перед нами, то говорим о конкретном значении этого типа. 

Тип данных определяет не только характеристики объекта, но и то, что с ними можно делать. Так, круг можно катить, а квадрат и прямоугольник устойчиво устанавливать друг на друга. 

Тип данных — это множество возможных значений и операций с этими значениями. В Swift типы данных определяют: 
- значения, которые хранятся в параметрах: целые числа, дробные числа, строки и отдельные символы, логические значения или другой вид информации; 
- операции, которые с этими значениями можно произвести: числа складывать или вычитать, строки объединять между собой и т. д. 

### Предназначение типов данных
Операция, в которой Swift самостоятельно определяет тип объявляемого параметра, основываясь на переданном значении, называется неявным определением типа. 

В противовес неявному определению существует явное, когда разработчик сам указывает тип данных объявляемого параметра. 

При явном (непосредственном) определении типа переменной или константы после имени ставится двоеточие и с помощью ключевого слова указывается тип данных. 

```swift
// создаем переменную orksName с неявным определением типа String
var orksName = "Artem"
// создаем переменную elfsName с явным определением типа String
var elfsName: String = "Tema"
```

Swift — язык со строгой типизацией. Однажды определив тип данных переменной или константы, вы уже не сможете его изменить. В каждый момент времени вы должны четко представлять, с каким типом значения работает ваш код. 
Все фундаментальные типы данных (строковые, числовые, логические и т. д.) являются значимыми (value type), то есть их значения передаются копированием. При передаче значения переменной или константы значимого типа в другую переменную или константу происходит копирование этого значения, в результате чего мы получаем два независимых параметра. 

```swift
// неявно определим параметр целочисленного типа данных
var variableOne = 23
// явно определим параметр целочисленного типа данных
// после чего передадим ему значение другого параметра в качестве первоначального
let variableOneCopy: Int = variableOne
print(variableOneCopy)       // 23
// изменим значение в первой переменной
variableOne = 25
print(variableOneCopy)      // 23
print(variableOne)              // 25
```

В данном примере хранилище `variableOne` — значимого типа. При передаче значения, хранящегося в variableOne, в новую переменную `variableOneCopy` создается полная независимая копия. Никакие изменения, вносимые в variableOne, не повлияют на значение, хранящееся в variableOneCopy. 

### Числовые типы данных 
Для объявления переменной или константы целочисленного типа используются ключевые слова `UInt` (для хранения только положительных значений) и `Int` (для хранения как положительных, так и отрицательных значений). 

```swift
// объявим переменную знакового целочисленного типа и присвоим ей значение
var signedNum: Int = -32
// объявим константу беззнакового целочисленного типа
// и проинициализируем ей значение
let unsignedNum: UInt = 128
```

В результате выполнения кода вы получите переменную signedNum целочисленного знакового типа Int со значением –32, а также константу unsignedNum целочисленного беззнакового типа UInt со значением 128. 

Разница между знаковыми и беззнаковыми целочисленными типами в том, что значение знакового типа данных может находиться в интервале от –2^n–2 до +2^n–2, а беззнакового — от 0 до +2^n–1, где n — разрядность типа данных (8, 16, 32 или 64). 

В Swift существуют дополнительные целочисленные типы данных: `#Int8, UInt8, Int16, UInt16, Int32, UInt32, Int64 и UInt64`. Они определяют диапазон возможных значений, хранимых в параметрах: 8, 16, 32 и 64-битные числа. 
***Все операции в Swift должны происходить между значениями одного и того же типа данных!*** 

A whole lot of number types. Множество числовых типов
For whole numbers, you can use the явно подписаные types Int8, Int16, Int32, Int64. These types потребляют 1, 2, 4, and 8 bytes для хранения. Each of these types use 1 bit to represent the sign.
Если вы имеете дело только с неотрицательными значениями, существует набор явных типов без знака, которые вы можете использовать. К ним относятся `#UInt8, UInt16, UInt32 and UInt64`.

<img alt="image" src="images/Тип данных Int.jpg"/>

***Float*** без веских причин лучше не использовать, лучше ***Double***. Float занимает вдвое меньше места чем Double, он имеет меньший диапозон и точность. Double имеет точность не менее 15 десятичных цифр, тогда как точность Float может составлять всего 6 десятичных цифр.В Swift всегда выбирай Double (а не Float).

Double represents a 64-bit floating-point number.
Float represents a 32-bit floating-point number.

<img alt="image" src="images/Тип данных Float.jpg"/>

```swift
let a: Int16 = 12
let b: UInt8 = 255
let c: Int32 = -100000
let answer = Int(a) + Int(b) + Int(c)   // answer is an Int

let anotherPi = 3 + 0.14159   // anotherPi is also inferred to be of type Double

let minValue = UInt8.min // minValue is equal to 0, and is of type UInt8 
let maxValue = UInt8.max // maxValue is equal to 255, and is of type UInt8
```

Cвойства `#min` и `#max`. Для примера получим максимально и минимально возможные значения для типов Int8 и UInt8 

```swift
// минимальное значение параметра типа Int8
let minInt8 = Int8.min // -128
// максимальное значение параметра типа Int8
let maxInt8 = Int8.max // 127
// минимальное значение параметра типа UInt8
let minUInt8 = UInt8.min // 0
// максимальное значение параметра типа UInt8
let maxUInt8 = UInt8.max // 255
```

так как тип данных UInt8 является беззнаковым и не предназначен для хранения отрицательных чисел, то и максимально возможное значение будет 255 вместо 127 у знакового Int8. 

### Объектные возможности Swift 
Swift обладает одной особенностью: всё в этом языке программирования является ***объектами***. 

Объект — это сущность, описанная кодом, объединяющая данные и действия, которые с этими данными можно совершить.

Например, объектом является цифра 2 или продуктовый автомат, если, конечно, он описан языком программирования. Каждая сущность обладает набором характеристик (называемых свойствами) и запрограммированных действий (называемых методами). Каждое свойство и каждый метод имеют имя, позволяющее использовать их. Так, например, у объекта продуктовый автомат могло бы существовать свойство вместимость и метод выдать товар, а у целого числа 2 свойство максимально возможное хранимое число и метод преобразовать в строку. 

Доступ к свойствам и методам объекта в Swift осуществляется с помощью их имен, написанных через точку после имени объекта, к примеру: 

`ПродуктовыйАвтомат.максимальнаяВместимость`

`ПродуктовыйАвтомат.выдатьТовар("шоколадка")`

***Метод*** — это та же функция, но описанная и используемая только в контексте определенного объекта. 

### Числа с плавающей точкой 

Помимо целых чисел, при разработке приложений вы можете использовать дробные числа. Например, 3.14 и -192.884022. 

Дробные числа в программировании также называются числами с плавающей точкой

Для хранения дробных чисел в большинстве случаев используются всего два типа данных: Float и Double, оба являются знаковыми (позволяют хранить положительные и отрицательные значения). 

`#Float` — позволяет хранить 32-битное число с плавающей точкой, содержащее до 6 знаков в дробной части. Float, сокращенно от слова с плавающей запятой, который хранит десятичные дроби с меньшей точностью, чем Double.

`#Double` — позволяет хранить 64-битное число с плавающей точкой, содержащее до 15 знаков в дробной части. Тип Double, хранит десятичные дроби (Decimal point ) с высокой точностью.

```swift
// дробное число типа Float с явным указанием типа
let numFloat: Float = 104.3
// дробное число типа Double с явным указанием типа
let numDouble: Double = 8.36
// дробное число типа Double с неявным указанием типа
let someNumber = 8.36
```

Обратите внимание, что тип константы someNumber задается неявно (с помощью переданного дробного числового значения). При передаче дробного значения без явного указания типа Swift **всегда самостоятельно определяет для параметра тип данных Double**. 

Фактически, точность Double примерно вдвое выше, чем у Float, поэтому она и называется Double. Float занимает меньше памяти, чем Double, но, как правило, использование памяти для чисел не является большой проблемой, и вы увидите, что Double используется в большинстве случаев.
После того, как вы объявили константу, вы не сможете изменить ее данные. 

```swift
let pi: Double = 3.14159
// варианты объявления
let actuallyDouble = Double(3)
let actuallyDouble: Double = 3
let actuallyDouble = 3 as Double
let wantADouble = 3.0
```

### Операторы
`%` бинарный оператор вычисления остатка от деления двух целочисленных значений. Тип результирующего значения соответствует типу операндов. 

Add: +
Subtract: -
Multiply: *
Divide: /

Integer – целое число, signed знаковые (positive, zero, or negative) or unsigned беззнаковые (positive or zero).
Когда вы используете оператор деления (/) для значений Int, результатом будет значение Int, округленное в меньшую сторону до ближайшего целого числа, поскольку тип Int поддерживает только целые числа, при использовании Double результат будет естественно дробный

```swift
let x = 51
let y = 4
let z = x / y // z has a value of 12
= assign a value, назначение значения
let name = “Artem”
```

The remainder operation or modulo operation. Оператор остатка %

В Swift есть специальный оператор #remainder #остатка в виде %, который используется для возврата остатка после полного деления одного числа на другое. Например, 14 % 3 равно 2, потому что вы можете уместить четыре тройки в 14, а затем у вас останется остаток 2. 14 - (4*3) = 14 - 12 = 2

```swift
let res = 19 % 4   // 3
let dividend = 10
let divisor = 3
let quotient = dividend / divisor // quotient has a value of 3
let remainder = dividend % divisor // remainder has a value of 1
```

You can calculate the remainder as dividend - (quotient * divisor)

Также в Swift существует функция вычисления остатка от деления, при которой первый операнд делится на второй и возвращается остаток от этого деления. Другими словами, программа определяет, как много значений второго операнда поместится в первом, и возвращает значение, которое осталось, — оно называется остатком от деления; остаток от деления всегда меньше делителя 

При использовании оператора вычисления остатка от деления (%) есть одно ограничение: он используется только для целочисленных значений. 

```swift
-9 % 4 // equals -1
```
`a % b` and `a % -b` всегда дают одинаковый ответ, `b` игнорирует минус

**Оператор остатка выше приоритетом** над * и /, он также полезен для вычисления таких вещей, как нечетные и четные числа – если вы хотите, чтобы альтернативные строки вашей таблицы были немного другого цвета:

```swift
for i in 1...10 {
    if i % 2 == 0 {
        print("Number is even")
    } else {
        print("Number is odd")
    }
}
let testNumber: Int = 46
let evenOdd: Int = testNumber % 3 // 1
```

Операция вычисления остатка от деления очень удобна в тех случаях, когда нужно проверить, является ли число четным или кратным какому-либо другому числу. Как определить четность? Очень просто: делите число на 2, и если остаток равен 0, то оно четное. 

Для определения #четности можно использовать специальный метод  
`#isMultiple(of: )`, применяемый к анализируемому числу. 

`(28.0).truncatingRemainder(dividingBy: 10.0)      // 8`

`.#truncatingRemainder(dividingBy: )` возвращает остаток от этого значения, деленный на заданное значение с использованием усекающего деления.

Для вычисления остатка от деления дробных чисел используется метод который применяется к делимому (то есть пишется через точку после числа, которое требуется разделить)

```swift
// дробные константы
let firstFloat: Float = 3.14
let secondFloat: Float = 1.01

// операция получения остатка от деления
let result1 = firstFloat.truncatingRemainder(dividingBy: secondFloat)  // 0.1100001

let result2 = -firstFloat.truncatingRemainder(dividingBy: secondFloat)  // -0.1100001

let result3 = firstFloat.truncatingRemainder(dividingBy: -secondFloat)  // 0.1100001
```

Type describes a set of values and the operations that can be performed on them. Тип описывает набор значений и операции, которые могут быть выполнены на них

### Operators with mixed types
What if you have an integer that you want to multiply by a double?
Вы не можете применять операторы к смешанным типам, нужно приведение к одному типу

`let hourlyRate: Double = 19.5`

`let hoursWorked: Int = 10`

Do you want the result to be an Int, converting the Double to an Int before performing the multiplication? Or do you want the result to be a Double, converting the Int to a Double before performing the multiplication? You need to tell Swift you want it to consider the hoursWorked constant to be a Double, so:
```swift
let totalCost: Double = hourlyRate * Double(hoursWorked) // 195
let totalCost: Int = Int(hourlyRate) * hoursWorked // 190 
```

### Increment and decrement or compound Assignment

```swift
var counter: Int = 0
counter += 1 // counter = 1
// тоже что и counter = counter + 1
counter -= 1 // counter = 0

var counter: Int = 0
counter = counter + 1
counter = counter - 1
```

Similarly, the `*=` and `/=` operators do the equivalent for multiplication and division :
```swift
counter = 10
counter *= 3  // same as counter = counter * 3
counter /= 2 // same as counter = counter / 2
```

### Процент от числа

<img alt="image" src="images/.jpg"/>

<img alt="image" src="images/.jpg"/>

<img alt="image" src="images/.jpg"/>

<img alt="image" src="images/name.jpg"/>

<img alt="image" src="images/name.jpg"/>

```swift

```

```swift

```

```swift

```

---
[К оглавлению](#contents)
###  <a id="chapter3" /> Глава №3. 


<img alt="image" src="images/name.jpg"/>

<img alt="image" src="images/name.jpg"/>

<img alt="image" src="images/name.jpg"/>

```swift

```

```swift

```

```swift

```

---
[К оглавлению](#contents)
###  <a id="chapter4" /> Глава №4. 


<img alt="image" src="images/name.jpg"/>

<img alt="image" src="images/name.jpg"/>

<img alt="image" src="images/name.jpg"/>

```swift

```

```swift

```

```swift

```

---
[К оглавлению](#contents)
###  <a id="chapter5" /> Глава №5. 


<img alt="image" src="images/name.jpg"/>

<img alt="image" src="images/name.jpg"/>

<img alt="image" src="images/name.jpg"/>

```swift

```

```swift

```

```swift

```

---
[К оглавлению](#contents)
###  <a id="chapter6" /> Глава №6. 


<img alt="image" src="images/name.jpg"/>

<img alt="image" src="images/name.jpg"/>

<img alt="image" src="images/name.jpg"/>

```swift

```

```swift

```

```swift

```

---
[К оглавлению](#contents)
###  <a id="chapter7" /> Глава №7. 



---
[К оглавлению](#contents)
###  <a id="chapter8" /> Глава №8. 



---
[К оглавлению](#contents)
###  <a id="chapter9" /> Глава №9. 



---
[К оглавлению](#contents)
###  <a id="chapter10" /> Глава №10. 



---
[К оглавлению](#contents)
###  <a id="chapter11" /> Глава №11. 



---
[К оглавлению](#contents)
###  <a id="chapter12" /> Глава №12. 



---
[К оглавлению](#contents)
###  <a id="chapter13" /> Глава №13. 



---
[К оглавлению](#contents)
###  <a id="chapter14" /> Глава №14. 



---
[К оглавлению](#contents)
###  <a id="chapter15" /> Глава №15. 



---
[К оглавлению](#contents)
###  <a id="chapter16" /> Глава №16. 



---
[К оглавлению](#contents)
###  <a id="chapter17" /> Глава №17. 



---
[К оглавлению](#contents)
###  <a id="chapter18" /> Глава №18. 



---
[К оглавлению](#contents)
###  <a id="chapter19" /> Глава №19. 



---
[К оглавлению](#contents)
###  <a id="chapter20" /> Глава №20. 



---
[К оглавлению](#contents)
###  <a id="chapter21" /> Глава №21. 



---
[К оглавлению](#contents)
###  <a id="chapter22" /> Глава №22. 



---
[К оглавлению](#contents)
###  <a id="chapter23" /> Глава №23. 



---
[К оглавлению](#contents)
###  <a id="chapter24" /> Глава №24. 



---
[К оглавлению](#contents)
###  <a id="chapter25" /> Глава №25. 



---
[К оглавлению](#contents)
###  <a id="chapter26" /> Глава №26. 



---
[К оглавлению](#contents)
###  <a id="chapter27" /> Глава №27. 

