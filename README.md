### Swift Manual
Конспект из разных источников

<a id="contents" />Оглавление

- [Глава №1. Основные понятия. Начало работы с Xcode.](#chapter1)
- [Глава  №2. Фундаментальные типы данных.](#chapter2)
- [Глава  №3. . ](#chapter3)
- [Глава  №4. . ](#chapter4)
- [Глава  №5. . ](#chapter5)
- [Глава  №6. . ](#chapter6)
- [Глава  №7. . ](#chapter7)
- [Глава  №8. . ](#chapter8)
- [Глава  №9. . ](#chapter9)
- [Глава  №10. . ](#chapter10)
- [Глава  №11. . ](#chapter11)
- [Глава  №12. . ](#chapter12)
- [Глава  №13. . ](#chapter13)
- [Глава  №14. . ](#chapter14)
- [Глава  №15. . ](#chapter15)
- [Глава  №16. . ](#chapter16)
- [Глава  №17. . ](#chapter17)
- [Глава  №18. . ](#chapter18)
- [Глава  №19. . ](#chapter19)
- [Глава  №20. . ](#chapter20)
- [Глава  №21. . ](#chapter21)
- [Глава  №22. . ](#chapter22)
- [Глава  №23. . ](#chapter23)
- [Глава  №24. . ](#chapter24)
- [Глава  №25. . ](#chapter25)
- [Глава  №26. . ](#chapter26)
- [Глава  №27. . ](#chapter27)

[К оглавлению](#contents)
###  <a id="chapter1" /> Глава №1. Основные понятия. Начало работы с Xcode

***[Help > Xcode Help](https://help.apple.com/xcode/mac/11.0/index.html)***

2 июня 2014 года компания представила язык программирования Swift. 

http://online.swiftplayground.run/ онлайн-редактор со встроенным компилятором Swift-кода 

Swift – это тип безопасный язык type-safe, означает, что язык помогает вам четко понимать, с какими типами значений может работать ваш код.

`Control-Command-F` – full-screen 
`Control-Left Arrow` and `Control-Right Arrow` перемещаться между приложениями

In December 2015, Apple released the Swift language
Консоль – это инструмент для ввода текста и отображения для администрирования системы

<img alt="image" src="images/Hello, World! В Terminal.jpg"/>

You can turn on line numbers on the left side of the source editor by clicking Xcode ▸ Preferences... ▸ Text Editing ▸ Line Numbers. 
View ▸ Debug Area ▸ Show Debug Area

IDE (integrated development environment) интегрированная среда разработки

Push notification – это сообщение, отправленное службой Push-уведомлений Apple (APNs) приложению, которое не работает на переднем плане. Уведомление может отображаться как уведомление пользователя или доставляться в автоматическом режиме, позволяя получающему приложению временно проснуться для обработки новых данных.

<img alt="image" src="images/Xcode interfaces 1.jpg"/>

<img alt="image" src="images/Xcode interfaces 2.jpg"/>

<img alt="image" src="images/Xcode interfaces 3.jpg"/>

<img alt="image" src="images/Xcode interfaces 4.jpg"/>

***Playground*** — это интерактивная среда разработки, своеобразная «песочница», или «игровая площадка», где вы можете тестировать создаваемый вами код и видеть результат его исполнения в режиме реального времени. 

Для создания нового playground-проекта выберите пункт главного меню `File > New > Playground`. Далее вам необходимо выбрать тип Blank, который содержит минимальное количество кода. 

`Option (Alt)` и щелкнуть на любом объекте в области кода, то появится вспомогательное окно, в котором можно узнать тип объекта, а также имя файла, где он расположен 
`.xcodeproj` file, which includes all the settings for your project and its targets. 

Проект, с которым вы работаете, имеет только одну цель: приложение iOS. В файле проекта вы можете изменить все детали конкретной цели. Например, в разделе «Deployment Info» вы можете указать, какая версия iOS ваш код должен поддерживать, изменять, какие устройства ваше приложение поддерживает для запуска или показать / скрыть строку состояния.

При выборе Signing & Capabilities (подписания и возможностей) в верхней части панели вы можете настроить подпись кода, что является требованием для развертывания устройств или в App Store. С этого экрана вы также можете включить различные функции в выбранной цели. Например, если ваша заявка должна принимать push-уведомления, вы можете добавить возможности Push-уведомления (Push Notifications capability), и Xсode настраивает все необходимое для вашего приложения для получения уведомлений из службы Apple Push Notifications. Вы можете добавить конфигурации возможностей, нажав кнопку Capability button +.

Некоторые возможности имеют параметры конфигурации, которые вы можете раскрывать, нажав треугольник рядом с ними

`.storyboard` files уникальны для интерфейса построителя. Они содержат информацию о дизайне каждой сцены в вашем приложении, а также как один экран переходит в другой. 

`.xcassets` file represents an asset catalog. In an asset catalog, you can manage many different kinds of assets. This includes your app's icon, images, color definitions, and другие формы данных, которые должны быть в комплекте с вашим приложением. Каталог активов (asset catalog) также позволяет указывать варианты своих активов на основе настроек и возможностей устройств, таких как светлый и темный внешний вид, настроек доступности для высоких и низких контрастных и аппаратных различий от экрана.

`info.plist` содержит список свойств и настроек для вашего приложения. Xcode предоставляет спец. интерфейс для редактирования этого файла

```bash
Command-B - построить проект.
Command-R - построить и запустить проект.
Command -. - Остановить сборку или запуск
Command - / - Переключить комментарии к выбранным строкам кода
Command - [- Сдвинуть выделенный код влево
Command -] - сдвинуть выделенный код вправо
Control-I - изменить выделение выбранного кода (выравнивает код)
Command-0 - показать и скрыть навигатор.
Option-Command-0 - показать и скрыть инспектор.
```

Чтобы узнать о сочетаниях клавиш, `Xcode> Preferences> Key Bindings`

---

### Какими должны быть размеры изображений в 1x, 2x и 3x в Xcode?
Вам нужно 3 вида изображений в ресурсах изображений, потому что с точки зрения масштабирования или пикселей cуществует 3 вида устройств Apple (iPhone и iPad), которые

-Обычное устройство, которое соответствует 1 pixel = 1 point #1x (более старые устройства iPhone и iPad)

-Устройство Retina, которое соответствует 4 pixels(2 x 2) = 1 point #2x (iPhone 4+)

-Retina iPhone 6 и iPad, которые соответствуют 9 pixels (3 x 3) = 1 point #3x (iPhone 6+)

Таким образом, для предоставления одного и того же изображения в 3 масштабах iOS решает, какое изображение показывать для каких устройств. 

<img alt="image" src="images/размеры изображений в 1x, 2x и 3x .jpg"/>

Важно при добавлении изображений в xcode верное именование, чтобы он сразу расставил их по нужным местам, например `Icon-20@2x.png` 

Вот размеры под iphone https://www.paintcodeapp.com/news 

App Icon Generator	https://appicon.co/#image-sets 

<img alt="image" src="images/App Icon Generator .jpg"/>

Копирование в xcode, зажимаем option и перетаскиваем копию объекта

<img alt="image" src="images/отображение элементов.jpg"/>

Exception тоже самое, что и Error.
Deprecated code – неподдверживаемый код.
- Warnings. Writing code that never gets executed (никогда не выполняется)
- Creating a variable that never changes (никогда не меняется)
- Using code that’s out of date (который устарел) or also known as deprecated code (устаревший код)

***Breakpoint***. In the debug area, show the variables view to inspect the current values. Вы увидите паузу программы в точке останова. Это хорошо. В области отладки отобразите представление переменных для проверки текущих значений (кнопка находится в правом нижнем углу). Поскольку строка с точкой останова еще не была выполнена, имена не содержат значений.

Отсюда вы можете использовать кнопки управления шагом в верхней части области отладки, чтобы медленно продолжить выполнение кода:

***Continue*** – возобновляет выполнение кода до тех пор, пока не будет достигнута следующая breakpoint. Если вы нажмете эту кнопку сейчас, код выйдет из строя, так как нет других breakpoint перед третьим name.removeFirst ().

***Step over*** – Перешагнуть – выполняет выбранную строку и приостанавливает выполнение на следующей строке.

***Step into***  –  Шаг внутрь – если щелкнуть строку с вызовом функции, переход к первой строке функции, затем снова останавливает выполнение.

***Step out*** – Выйти – выполняет все оставшиеся строки в вызове функции и приостанавливает выполнение на строке после функции

<img alt="image" src="images/пример error.jpg"/>

При исправлении кода, также в этой панели будет положительный результат и все отображения операций. Благодаря breakpoint можно исправлять баги и решать проблемы в app при вылетах или ошибках.

***Действие или IBAction*** соединяет метод в исходном коде и элемент управления в Interface Builder, позволяющий запускать определенный код при взаимодействии пользователя с элементами управления приложения. Например, определенный метод может быть связан с действием, таким как нажатие кнопки или изменение переключателя, taps.

***Холст or Canvas*** относится к фону раскадровки, где вы добавляете и упорядочиваете сцены и элементы пользовательского интерфейса (UI)

***Выход или IBOutlet*** соединяет переменную в исходном коде с объектом в раскадровке, позволяя коду получать информацию от объекта и вносить изменения по мере запуска приложения.

***Файл XIB*** представляет собой одну сцену или представление в iOS и может быть открыт и изменен в Interface Builder. Файлы XIB были более популярны до появления раскадровки в iOS 5.

Контроллер вида (view controller) управляет набором представлений и координирует поток информации между моделью данных приложения и представлениями, отображающими данные.

Контроллер начального вида – это первая сцена, которая будет просмотрена пользователем при запуске приложения. В раскадровках контроллер начального вида отмечен серой ***стрелкой***, но вы также можете установить контроллер начального вида в Attributes inspector для отдельной сцены.
Вы можете изменить view controller, переместив точку входа (стрелка в правой стороне) слева от нужного контроллера просмотра. В настоящее время в этом проекте Main.Storyboard имеет только один контроллер просмотра, поэтому вы не сможете его изменить.

***Identity inspector*** – позволяет редактировать свойства, связанные с идентичностью объекта, например, к какому классу он принадлежит. В этом примере кнопка принадлежит к классу UIButton. Если вы определили пользовательский класс кнопки в другом месте, вы можете использовать инспектор идентификатора, чтобы изменить класс кнопки, которую вы только что добавили. 

***Attributes inspector*** предоставляет список регулируемых визуальных свойств для выбранного элемента. В случае UIButton вы можете изменить такие атрибуты, как текст кнопки, цвет текста, фона и выравнивание. 

***Size inspector*** – позволяет настроить размер и положение выбранного элемента внутри сцены. Вы будете использовать поля x и y - где вверху слева экрана соответствует (0,0) - изменять положение. Значение x становится больше, когда вы перемещаете элемент дальше вправо, а y становится больше, когда вы двигаетесь вниз по экрану. Для UIButton инспектор размера включает в себя дополнительные поля для настройки прокладки вокруг заголовка или изображения кнопки.

***Connections inspector*** перечисляет все функции и имена переменных, относящиеся к объекту, и как они связаны

Если xcode тормозит или выполнение кода зависло, то:

- Завершите процесс зависшего симулятора. Для этого откройте `Программы > Утилиты > Мониторинг системы`, после чего найдите и завершите процесс `com.apple.CoreSimulator. CoreSimulatorService.` 

- Измените платформу playground-проекта с iOS на macOS. Для этого нажмите кнопку Hide or Show the Inspector, расположенную в правом верхнем углу, и в поле Platform выберите необходимый пункт. В этом случае вам надо внести правки в первую строку в редакторе кода: заменить import UIKit на import Foundation, так как библиотека UIKit доступна исключительно в мобильных операционных системах iOS и iPadOS. 

---

### Outlets and Actions
Нужен способ связки ваших визуальных элементов с кодом, чтобы их можно было отрегулировать во время выполнения или когда приложение уже запущено. Эта ссылка из Interface Builder к коду называется ***outlet***. Когда у вас есть объект, c которым вы хотите, чтобы пользователь мог взаимодействовать, вы создаете ***action***– ссылку на кусок кода, который будет выполнен при взаимодействия с ним пользователя (нажатие, переключение) 

***Creating an #Outlet or #Action***.
Control-click the button in the storyboard, and start dragging toward the assistant editor pane that contains the ViewController class definition. As you drag the pointer into the code, you see a blue line.

<img alt="image" src="images/Creating an Outlet or Action1.jpg"/>

<img alt="image" src="images/Creating an Outlet or Action2.jpg"/>

<img alt="image" src="images/Creating an Outlet or Action3.jpg"/>

Имя которое мы даем выше в появляющимся окне, сохраняется внутри кода и связывается с объектом, все это под капотом, поэтому нельзя просто так изменять имя в коде, будет ошибка. Необходимо удалить привязку, для этого нажимаем правую клавишу (тап с 2 пальцами) и удаляем привязку.

<img alt="image" src="images/Creating an Outlet or Action4.jpg"/>

Или безопасно переименовать из меню

<img alt="image" src="images/Rename an Outlet or Action1.jpg"/>

Все свойства из Interface Builder можно применить программно, явно прописав их в коде, есть свойства которых нет в Interface Builder и они указываются только программно. Например:

`UIScrollView` has a contentSize property that does not have a matching option in the Attributes inspector.
`scrollView.contentSize = CGSize(width: 100, height: 100)`

### Основные понятия работы компьютера
Все элементы компьютера в общем случае можно разделить на три основных функциональных уровня аппаратный, операционной системы и программный. 

Аппаратный уровень представлен физическим оборудованием компьютера. Это та основа, на которой базируются остальные уровни. Самые важные элементы аппаратного уровня — это центральный процессор (CPU, Central Processing Unit) и оперативная память. 

Данные, с которыми работает процессор, хранятся во временном хранилище — оперативной памяти.

Оперативная память — это основное средство хранения данных, используемое программами в ходе их функционирования. Память компьютера состоит из миллионов отдельных ячеек, каждая из которых может хранить небольшой объем информацию. Каждая ячейка имеет уникальный адрес, по которому ее можно найти в памяти. Но размер ячейки не позволяет хранить в ней большое количество данных, по этой причине ячейки логически объединяются в хранилища данных.

Хранилище может объединять произвольное количество ячеек, его размер определяется количеством записанной информации и при необходимости может изменяться. Как и ячейка памяти, хранилище имеет уникальный адрес, по которому может быть получено хранящееся в нем значение (обычно он соответствует адресу первой входящей в него ячейки) 

<img alt="image" src="images/оперативная память.jpg"/>

Оперативная память хранит нужные данные так долго, как этого требует ваше приложение (ограничиваясь лишь временем, пока оно запущено). Для постоянного (долговременного) хранения информации используются др. элементы аппаратного уровня, например HDD или SSD. 

Операционная система (ОС) — это посредник между вашей программой и аппаратной частью. 

Программный уровень — это все программы, которые работают на вашем компьютере в среде операционной системы. 

<img alt="image" src="images/уровни памяти и взаимодействия.jpg"/>

Хранилище данных это виртуальный объект со свойствами: 
- записанное значение; 
- идентификатор (имя); 
- тип информации, для хранения которой предназначено хранилище (числовой, строковый и др.). 

Практически весь процесс программирования заключается в том, чтобы создавать (объявлять) объекты, задавать (инициализировать или рисваивать) им значения, получать эти значения из памяти и производить с ними операции. 

Объявление — это создание нового объекта (хранилища данных). 

Инициализация — это присвоение значения объекту. 

```bash
СоздатьХранилище с именем value1 и значением 23
СоздатьХранилище с именем value2 и значением 145
СоздатьХранилище с именем result и значением value1 * value2 // 3335
```

<img alt="image" src="images/СоздатьХранилище с именами.jpg"/>

Хранилища данных могут содержать в себе не только цифры, но и другие виды информации (текстовую, графическую, логическую и др.). Виды информации в программировании называются типами данных. При объявлении хранилища ему всегда назначается тип данных, определяющий, какие именно данные будут храниться в нем. 

***Выражение*** — команда, выполняющая одну или несколько операций. Выражение может состоять из множества операторов и операндов. 

***Оператор*** — это минимальная независимая функциональная единица (символ, слово или группа слов), выполняющая определенную операцию. 

***Операнд*** — это значение, с которым оператор производит операцию.

```swift
import UIKit
var str = "Hello, playground"
```

С помощью ключевого слова (оператора) var объявляется новое хранилище данных с именем str. Этому хранилищу инициализируется (присваивается) текстовое значение Hello, playground. Этот процесс и называется инициализацией значения с помощью оператора `= (присваивания)`. 

---

### Классификация операторов operators
The values that #operators affect are operands. In the expression 1 + 2, the + symbol is a binary operator and its two operands are the values 1 and 2.

Простые операторы, выполняющие операции со значениями (операндами). В их состав входят унарные и бинарные операторы. 

-Unary operators operate on a single target (`-a`). Unary prefix operators (`!b`), and unary postfix operators (`c!`).

```swift
let three = 3 
let minusThree = -three // minusThree equals -3 
let plusThree = -minusThree // plusThree equals 3, or "minus minus three"
```
***Унарные операторы*** выполняют операцию с одним операндом. Они могут находиться перед операндом (префиксные) или после него (постфиксные). 

Оператор `var`, с помощью которого объявляется хранилище данных, или оператор минус (`-a`), с помощью которого создаются отрицательные числа, являются унарными префиксными. 

***Постфиксные операторы***, например, многоточие (`...`) в выражении `1...` указывает на все целые числа после единицы. ***Префиксные операторы*** `…5`

***Бинарные операторы*** выполняют операцию с двумя операндами. Оператор, который располагается между операндами, называется ***инфиксным***. Binary operators operate on two targets (`2 + 3`)

***Оператор инициализации*** (`=`) и ***оператор сложения*** (`+`) являются бинарными инфиксными, так как использует в работе два операнда и находятся между ними (`value1 = 12 или 34+12`). 

***Структурные операторы*** влияют на ход выполнения программы. Например, останавливают выполнение программы при определенных условиях или указывают программе, какой блок кода должен быть выполнен при определенных условиях. -***Ternary operators operate*** on three targets. the ternary conditional operator (`a ? b : c`).

***Оператор инициализации (присваивания)*** (`=`) — это бинарный оператор. Он используется в типовом выражении `a = b`, присваивая хранилищу данных с именем `a` значение хранилища данных с именем `b`. В листинге объекту `str` инициализируется текстовое значение Hello, playground 

Assignment operator – оператор присваивания = 
initializes or updates the value of a with the value

```swift
let b = 10 
var a = 5 
a = b     // a is now equal to 10 
```
Если правая часть присваивания представляет собой кортеж с несколькими значениями, его элементы можно разложить на несколько констант или переменных одновременно:

```swift
let (x, y) = (1, 2)       // x is equal to 1, and y is equal to 2
```

***переменные***, объявляемые с помощью ключевого слова `var`;

***константы***, объявляемые с помощью ключевого слова `let`. 

---

### Naming data. Variables
When you know you’ll need to change some data, you should use a variable

```swift
var variableNumber: Int = 42
variableNumber = 0
variableNumber = 1_000_000
```

Переменные для хранения значений, которые могут изменяться в ходе выполнения кода. 

***Переменная*** — это хранилище данных, значение которого может быть многократно изменено разработчиком в процессе работы программы. 

   `var имяПеременной = значениеПеременной`

Имя несет в себе type annotation, которая указывает, к какому типу данных относится это имя, например, текст, числа или дата

---

### Constants
```swift
let number: Int = 10
var anotherNumber = number
anotherNumber = 30 + number
```

This declares a constant called number which is of type Int. Then it sets the value of the constant to the number 10.

Константа присвоить значение можно только один раз. Все последующие попытки изменить его вызовут ошибку. 

Константы объявляются с помощью оператора let. 
   `let имяКонстанты = значениеКонстанты`

**Константы** – базовое средство оптимизации используемых мощностей. Поэтому если инициализированное значение не планируется изменять, программисты всегда должны использовать константы. Константы для хранения значений, которые не должны и не будут изменяться в ходе выполнения кода. 

Имя пользователя. 
  `let username = "Artem"`

Устройство, на котором запущено приложение. 
  `let phoneModel = "iPhone 15"`

Объявление нескольких параметров в одном выражении 
При объявлении нескольких параметров вы можете использовать один оператор – `var` или `let` и через запятую попарно указать их имена и инициализируемые значения.

```swift
let friend1 = "John", friend2 = "Helga"
var age1 = 54, age2 = 25
var x = 0.0, y = 0.0, z = 0.0
```

---
### Type inference – Вывод типа
Вывод типа. Swift использует вывод типов для определения типа объекта на основе доступной информации, даже если имя типа явно не выражено словами в коде. Например, если объявлена функция, возвращающая `String`, например `func answer() -> String`, и константа инициализируется результатом `func answer`, например `let nextIdea = answer()`, тип `nextIdea` будет выведен как `String`.

Вывод типа – когда swift сам понимает какой тип данных вы назначили в `var` or `let`, т.е без явного указания. Неявное объявление. Вам не нужно объявлять константы или переменные как Bool/Int/Double и тп, если вы устанавливаете для них значение сразу после их создания. Вывод типа помогает сделать код Swift более кратким и читаемым, когда он инициализирует константы или переменные другими значениями, тип которых уже известен.

Как только вы назначаете значение `let` или `var`, тип устанавливается и не может быть изменен. Значение `var` может измениться, но не его **тип**.

***Нельзя поменять тип присвоенного значения, можно переконвертировать в другое, но не изменить, так как он уже назначен.***

Три примера для использования type annotation:

1. When you create a constant or variable but не назначаете it a value.
```swift
let firstName: String
//... 
firstName = “Layne”
```

2. When you create a constant or variable that could be предполагать as more than one type.
```swift
let middleInitial: Character = “J”
// “J” would be inferred as a `String`, but we want a `Character` 
 
var remainingDistance: Double = 30
// `30` would be inferred as an `Int`, but the variable should support decimal numbers for accuracy as the number decreases. 
```

3. When you write your own type definition.
```swift
struct Car {
  var make: String
  var model: String
  var year: Int
}
```

Чтобы узнать тип нажимаем `Option` и кликаем на имя.

This uses a new keyword you haven’t seen before, `as`. It also performs a type conversion. Это также выполняет преобразование типа явно в `Double`

```swift
let actuallyDouble = 3 as Double // тип Double
```

---
### Инициализация копированием 
Инициализацию значения любых параметров (переменных и констант) можно проводить, указывая в правой части выражения не только конкретное значение, но и имя другого параметра

```swift
let myAge = 40
var yourAge = myAge
yourAge
```

Таким образом вы создаете ***копию*** исходного значения, то есть в результате операции будет объявлена константа и переменная с двумя независимыми значениями. Изменение одного из них не повлияет на другое. 

Тип данных параметра, который обеспечивает передачу значения **копированием, называется #value type** (значимый тип, или тип-значение). 

Помимо передачи значения копированием, существует **передача ссылки на значение**, когда несколько параметров содержат в себе **ссылку на одно и то же значение, хранящееся в памяти**. Тип данных, который обеспечивает передачу значения **ссылкой, называется #reference type (ссылочный тип, или тип-ссылка)**. При этом изменение значения через любой из параметров отразится и на всех копиях-ссылках. Другими словами, параметры ссылочного типа устанавливают для ячейки памяти несколько имен.

**Кодовые сниппеты** – это шаблоны, позволяющие быстро создавать типовые конструкции. 

Библиотеку кодовых сниппетов можно открыть с помощью кнопки с изображением символа `+`, расположенной в верхней части `Xcode Playground`.

---

### Область видимости (scope) 

У каждого объекта есть область его применения, или, другими словами, область видимости #scope, которая определяет, где именно данный объект может быть использован. Например, область видимости объекта может быть ограничена файлом или отдельным блоком кода. 

По области видимости объекты можно разделить на два вида: 

**Глобальные** — это объекты, доступные в любой точке программы. 

**Локальные** — это объекты, доступные в пределах родительского объекта. 

<img alt="image" src="images/Область видимости.jpg"/>

Объекты `User` и `Friend` объявлены непосредственно в корне программы. Такие объекты называются глобальными, они доступны в любой точке программного кода. 

Каждый из глобальных объектов из примера выше содержит внутренние, локальные по отношению к нему, объекты: 
- В составе `User` есть объект `login`; 
- В составе `Friend` есть два объекта: `name` и `surname`. 
Локальные объекты доступны только в пределах своего контекста, то есть родительского объекта. 

---
### Комментарии и Markdown
#Markdown-комментарии должны начинаться с двойной косой черты и двоеточия (`//:`), после которых следует текст комментария. 

Включить форматирование комментариев, при котором все markdown-комментарии отобразятся в красивом и удобном для чтения стиле, можно, выбрав в меню Xcode пункт `Editor > Show Rendered Markup`. 

Вернуть markdown-комментарии к прежнему неформатированному виду можно, выбрав в меню пункт `Editor > Show Raw Markup`.

```swift 
// This is also a comment.
// Over multiple lines

/* This is also a comment.
   Over many..
   many...
   many lines. */
```

<img alt="image" src="images/Markdown1.jpg"/>

<img alt="image" src="images/Markdown2.jpg"/>

Переданное в функцию значение используется внутри нее и в ее пределах называется входным параметром. 

Не стоит путать понятия аргумент функции и входной параметр.

***Аргумент функции*** – то, что передается в функцию в скобках при ее вызове

***Входной параметр*** – то, что используется внутри функции. 

По сути, это может быть одно и то же значение, но во время вызова функции — это аргумент, а в теле функции — это параметр. 

Каждая функция имеет сигнатуру, то есть краткое описание. Сигнатура содержит информацию об имени функции, ее аргументах и возвращаемом функцией значении. Она может быть в одной из трех форм: 

1. Полная, с указанием типов данных:  
     `someFunction(a:String, b: String) -> String`
2. Стандартная, без указания типов данных:  
     `someFunction(a: b:)`
3. Краткая, с указанием только имени функции:  
     `someFunction`

Если функция принимает входные аргументы, то это отражается в сигнатуре. 

`print(_:)` описывает функцию с именем print, которая принимает один входной безымянный аргумент. 

`anotherFunction(name:)` описывает функцию с именем anotherFunction, которая принимает один аргумент с именем name. 

`someFunction(a:b:)` описывает функцию с именем someFunction, которая имеет два вход- ных аргумента с именами a и b. 

`myFunction()` описывает функцию с именем myFunction, которая не имеет аргументов. может служить функция print(_:)). 

Таким образом сигнатура кратко описывает не только название функции, но и ее аргументы. 
Если аргумент не имеет имени, то вместо его имени ставится нижнее подчеркивание ` _ `

Таким образом, сигнатура `goodFunction(_: text:)` указывает на функцию с именем goodFunction, которой нужны два аргумента: первый не имеет имени, а второй должен быть передан с именем text. 

Пример вызова функции `goodFunction (_: text:)`

`goodFunction(21, text: "Hello!")`

Cуществует возможность объединить вывод текстовой информации со значением некоторого параметра (или параметров). Для этого используется символ обратной косой черты (слеша) ` \(…)`, после которого в круглых скобках нужно указать имя выводимого параметра

```python
let bar = "Swift"
print("Я изучаю \(bar)") // Я изучаю Swift
```

---
[К оглавлению](#contents)
###  <a id="chapter2" /> Глава №2. Фундаментальные типы данных 

Тип данных определяет вид информации, которая может храниться в параметре. Например, параметр со строковым типом данных сможет хранить только строковые значения. 

Если точнее, то ***тип данных*** — это множество всех возможных значений, а также операций над ними. Например, если у параметра числовой тип данных, то ему может быть присвоено числовое значение, с которым можно проводить математические операции (сложение, вычитание, деление, умножение и т. д.). Воспринимайте типы данных как абстракции, шаблоны, на основе которых создаются конкретные значения. Например, на основе типа данных «целое число» можно создать значения 2, 17, 36. Сам по себе тип «целое число» лишь выделяет диапазон возможных значений, но не несет никакой конкретики, никакой точной величины. 
Если мы говорим о какой-то типовой фигуре (о квадрате или о шаре в широком смысле), то говорим о типе данных; если мы говорим о конкретной фигуре (этот большой зеленый куб), расположенной перед нами, то говорим о конкретном значении этого типа. 

Тип данных определяет не только характеристики объекта, но и то, что с ними можно делать. Так, круг можно катить, а квадрат и прямоугольник устойчиво устанавливать друг на друга. 

Тип данных — это множество возможных значений и операций с этими значениями. В Swift типы данных определяют: 
- значения, которые хранятся в параметрах: целые числа, дробные числа, строки и отдельные символы, логические значения или другой вид информации; 
- операции, которые с этими значениями можно произвести: числа складывать или вычитать, строки объединять между собой и т. д. 

### Предназначение типов данных
Операция, в которой Swift самостоятельно определяет тип объявляемого параметра, основываясь на переданном значении, называется неявным определением типа. 

В противовес неявному определению существует явное, когда разработчик сам указывает тип данных объявляемого параметра. 

При явном (непосредственном) определении типа переменной или константы после имени ставится двоеточие и с помощью ключевого слова указывается тип данных. 

```swift
// создаем переменную orksName с неявным определением типа String
var orksName = "Artem"
// создаем переменную elfsName с явным определением типа String
var elfsName: String = "Tema"
```

Swift — язык со строгой типизацией. Однажды определив тип данных переменной или константы, вы уже не сможете его изменить. В каждый момент времени вы должны четко представлять, с каким типом значения работает ваш код. 
Все фундаментальные типы данных (строковые, числовые, логические и т. д.) являются значимыми (value type), то есть их значения передаются копированием. При передаче значения переменной или константы значимого типа в другую переменную или константу происходит копирование этого значения, в результате чего мы получаем два независимых параметра. 

```swift
// неявно определим параметр целочисленного типа данных
var variableOne = 23
// явно определим параметр целочисленного типа данных
// после чего передадим ему значение другого параметра в качестве первоначального
let variableOneCopy: Int = variableOne
print(variableOneCopy)       // 23
// изменим значение в первой переменной
variableOne = 25
print(variableOneCopy)      // 23
print(variableOne)              // 25
```

В данном примере хранилище `variableOne` — значимого типа. При передаче значения, хранящегося в variableOne, в новую переменную `variableOneCopy` создается полная независимая копия. Никакие изменения, вносимые в variableOne, не повлияют на значение, хранящееся в variableOneCopy. 

### Числовые типы данных 
Для объявления переменной или константы целочисленного типа используются ключевые слова `UInt` (для хранения только положительных значений) и `Int` (для хранения как положительных, так и отрицательных значений). 

```swift
// объявим переменную знакового целочисленного типа и присвоим ей значение
var signedNum: Int = -32
// объявим константу беззнакового целочисленного типа
// и проинициализируем ей значение
let unsignedNum: UInt = 128
```

В результате выполнения кода вы получите переменную signedNum целочисленного знакового типа Int со значением –32, а также константу unsignedNum целочисленного беззнакового типа UInt со значением 128. 

Разница между знаковыми и беззнаковыми целочисленными типами в том, что значение знакового типа данных может находиться в интервале от –2^n–2 до +2^n–2, а беззнакового — от 0 до +2^n–1, где n — разрядность типа данных (8, 16, 32 или 64). 

В Swift существуют дополнительные целочисленные типы данных: `#Int8, UInt8, Int16, UInt16, Int32, UInt32, Int64 и UInt64`. Они определяют диапазон возможных значений, хранимых в параметрах: 8, 16, 32 и 64-битные числа. 
***Все операции в Swift должны происходить между значениями одного и того же типа данных!*** 

A whole lot of number types. Множество числовых типов
For whole numbers, you can use the явно подписаные types Int8, Int16, Int32, Int64. These types потребляют 1, 2, 4, and 8 bytes для хранения. Each of these types use 1 bit to represent the sign.
Если вы имеете дело только с неотрицательными значениями, существует набор явных типов без знака, которые вы можете использовать. К ним относятся `#UInt8, UInt16, UInt32 and UInt64`.

<img alt="image" src="images/Тип данных Int.jpg"/>

***Float*** без веских причин лучше не использовать, лучше ***Double***. Float занимает вдвое меньше места чем Double, он имеет меньший диапозон и точность. Double имеет точность не менее 15 десятичных цифр, тогда как точность Float может составлять всего 6 десятичных цифр.В Swift всегда выбирай Double (а не Float).

Double represents a 64-bit floating-point number.
Float represents a 32-bit floating-point number.

<img alt="image" src="images/Тип данных Float.jpg"/>

```swift
let a: Int16 = 12
let b: UInt8 = 255
let c: Int32 = -100000
let answer = Int(a) + Int(b) + Int(c)   // answer is an Int

let anotherPi = 3 + 0.14159   // anotherPi is also inferred to be of type Double

let minValue = UInt8.min // minValue is equal to 0, and is of type UInt8 
let maxValue = UInt8.max // maxValue is equal to 255, and is of type UInt8
```

Cвойства `#min` и `#max`. Для примера получим максимально и минимально возможные значения для типов Int8 и UInt8 

```swift
// минимальное значение параметра типа Int8
let minInt8 = Int8.min // -128
// максимальное значение параметра типа Int8
let maxInt8 = Int8.max // 127
// минимальное значение параметра типа UInt8
let minUInt8 = UInt8.min // 0
// максимальное значение параметра типа UInt8
let maxUInt8 = UInt8.max // 255
```

так как тип данных UInt8 является беззнаковым и не предназначен для хранения отрицательных чисел, то и максимально возможное значение будет 255 вместо 127 у знакового Int8. 

### Объектные возможности Swift 
Swift обладает одной особенностью: всё в этом языке программирования является ***объектами***. 

Объект — это сущность, описанная кодом, объединяющая данные и действия, которые с этими данными можно совершить.

Например, объектом является цифра 2 или продуктовый автомат, если, конечно, он описан языком программирования. Каждая сущность обладает набором характеристик (называемых свойствами) и запрограммированных действий (называемых методами). Каждое свойство и каждый метод имеют имя, позволяющее использовать их. Так, например, у объекта продуктовый автомат могло бы существовать свойство вместимость и метод выдать товар, а у целого числа 2 свойство максимально возможное хранимое число и метод преобразовать в строку. 

Доступ к свойствам и методам объекта в Swift осуществляется с помощью их имен, написанных через точку после имени объекта, к примеру: 

`ПродуктовыйАвтомат.максимальнаяВместимость`

`ПродуктовыйАвтомат.выдатьТовар("шоколадка")`

***Метод*** — это та же функция, но описанная и используемая только в контексте определенного объекта. 

### Числа с плавающей точкой 

Помимо целых чисел, при разработке приложений вы можете использовать дробные числа. Например, 3.14 и -192.884022. 

Дробные числа в программировании также называются числами с плавающей точкой

Для хранения дробных чисел в большинстве случаев используются всего два типа данных: Float и Double, оба являются знаковыми (позволяют хранить положительные и отрицательные значения). 

`#Float` — позволяет хранить 32-битное число с плавающей точкой, содержащее до 6 знаков в дробной части. Float, сокращенно от слова с плавающей запятой, который хранит десятичные дроби с меньшей точностью, чем Double.

`#Double` — позволяет хранить 64-битное число с плавающей точкой, содержащее до 15 знаков в дробной части. Тип Double, хранит десятичные дроби (Decimal point ) с высокой точностью.

```swift
// дробное число типа Float с явным указанием типа
let numFloat: Float = 104.3
// дробное число типа Double с явным указанием типа
let numDouble: Double = 8.36
// дробное число типа Double с неявным указанием типа
let someNumber = 8.36
```

Обратите внимание, что тип константы someNumber задается неявно (с помощью переданного дробного числового значения). При передаче дробного значения без явного указания типа Swift **всегда самостоятельно определяет для параметра тип данных Double**. 

Фактически, точность Double примерно вдвое выше, чем у Float, поэтому она и называется Double. Float занимает меньше памяти, чем Double, но, как правило, использование памяти для чисел не является большой проблемой, и вы увидите, что Double используется в большинстве случаев.
После того, как вы объявили константу, вы не сможете изменить ее данные. 

```swift
let pi: Double = 3.14159
// варианты объявления
let actuallyDouble = Double(3)
let actuallyDouble: Double = 3
let actuallyDouble = 3 as Double
let wantADouble = 3.0
```

### Операторы
`%` бинарный оператор вычисления остатка от деления двух целочисленных значений. Тип результирующего значения соответствует типу операндов. 

Add: +
Subtract: -
Multiply: *
Divide: /

Integer – целое число, signed знаковые (positive, zero, or negative) or unsigned беззнаковые (positive or zero).
Когда вы используете оператор деления (/) для значений Int, результатом будет значение Int, округленное в меньшую сторону до ближайшего целого числа, поскольку тип Int поддерживает только целые числа, при использовании Double результат будет естественно дробный

```swift
let x = 51
let y = 4
let z = x / y // z has a value of 12
= assign a value, назначение значения
let name = “Artem”
```

The remainder operation or modulo operation. Оператор остатка %

В Swift есть специальный оператор #remainder #остатка в виде %, который используется для возврата остатка после полного деления одного числа на другое. Например, 14 % 3 равно 2, потому что вы можете уместить четыре тройки в 14, а затем у вас останется остаток 2. 14 - (4*3) = 14 - 12 = 2

```swift
let res = 19 % 4   // 3
let dividend = 10
let divisor = 3
let quotient = dividend / divisor // quotient has a value of 3
let remainder = dividend % divisor // remainder has a value of 1
```

You can calculate the remainder as dividend - (quotient * divisor)

Также в Swift существует функция вычисления остатка от деления, при которой первый операнд делится на второй и возвращается остаток от этого деления. Другими словами, программа определяет, как много значений второго операнда поместится в первом, и возвращает значение, которое осталось, — оно называется остатком от деления; остаток от деления всегда меньше делителя 

При использовании оператора вычисления остатка от деления (%) есть одно ограничение: он используется только для целочисленных значений. 

```swift
-9 % 4 // equals -1
```
`a % b` and `a % -b` всегда дают одинаковый ответ, `b` игнорирует минус

**Оператор остатка выше приоритетом** над * и /, он также полезен для вычисления таких вещей, как нечетные и четные числа – если вы хотите, чтобы альтернативные строки вашей таблицы были немного другого цвета:

```swift
for i in 1...10 {
    if i % 2 == 0 {
        print("Number is even")
    } else {
        print("Number is odd")
    }
}
let testNumber: Int = 46
let evenOdd: Int = testNumber % 3 // 1
```

Операция вычисления остатка от деления очень удобна в тех случаях, когда нужно проверить, является ли число четным или кратным какому-либо другому числу. Как определить четность? Очень просто: делите число на 2, и если остаток равен 0, то оно четное. 

Для определения #четности можно использовать специальный метод  
`#isMultiple(of: )`, применяемый к анализируемому числу. 

`(28.0).truncatingRemainder(dividingBy: 10.0)      // 8`

`.#truncatingRemainder(dividingBy: )` возвращает остаток от этого значения, деленный на заданное значение с использованием усекающего деления.

Для вычисления остатка от деления дробных чисел используется метод который применяется к делимому (то есть пишется через точку после числа, которое требуется разделить)

```swift
// дробные константы
let firstFloat: Float = 3.14
let secondFloat: Float = 1.01

// операция получения остатка от деления
let result1 = firstFloat.truncatingRemainder(dividingBy: secondFloat)  // 0.1100001

let result2 = -firstFloat.truncatingRemainder(dividingBy: secondFloat)  // -0.1100001

let result3 = firstFloat.truncatingRemainder(dividingBy: -secondFloat)  // 0.1100001
```

Type describes a set of values and the operations that can be performed on them. Тип описывает набор значений и операции, которые могут быть выполнены на них

### Operators with mixed types
What if you have an integer that you want to multiply by a double?
Вы не можете применять операторы к смешанным типам, нужно приведение к одному типу

`let hourlyRate: Double = 19.5`

`let hoursWorked: Int = 10`

Do you want the result to be an Int, converting the Double to an Int before performing the multiplication? Or do you want the result to be a Double, converting the Int to a Double before performing the multiplication? You need to tell Swift you want it to consider the hoursWorked constant to be a Double, so:
```swift
let totalCost: Double = hourlyRate * Double(hoursWorked) // 195
let totalCost: Int = Int(hourlyRate) * hoursWorked // 190 
```

### Increment and decrement or compound Assignment

```swift
var counter: Int = 0
counter += 1 // counter = 1
// тоже что и counter = counter + 1
counter -= 1 // counter = 0

var counter: Int = 0
counter = counter + 1
counter = counter - 1
```

Similarly, the `*=` and `/=` operators do the equivalent for multiplication and division :
```swift
counter = 10
counter *= 3  // same as counter = counter * 3
counter /= 2 // same as counter = counter / 2
```

### Процент от числа
Imagine that partway through the day a user has taken 3,467 steps out of the 10,000 step goal. Create constants steps and goal. Both will need to be of type Double so that you can perform accurate calculations. steps should be assigned the value 3,467, and goal should be assigned 10,000. Create a constant percentOfGoal that equals an expression that evaluates to the percent of the goal that has been achieved so far.
```swift
let steps1:Double = 3467
let goal1: Double = 10_000
let percentOfGoal1 = steps / goal * 100 //34.67

let steps2: Int = 4550
let goal2: Int = 6000
let percentOfGoal3 = Double(steps) / Double(goal) * 100 // 75.83
```

В Swift отсутствуют довольно популярные в других языках операторы `инкремента (++)` и `декремента (--)`, увеличивающие и уменьшающие значение на единицу соответственно. Использование составного оператора является заменой операторам инкремента и декремента, которую предлагает нам Apple. 
Составной оператор присваивания 

```swift
// переменная типа Int
var count = 19
// прибавим к ней произвольное число
count += 5 // 24
/* эта операция аналогична выражению
count = count + 5 */
// умножим его на число 3
count *= 3 // 72
/* эта операция аналогична выражению
count = count * 3 */
// вычтем из него число 3
count -= 3 // 69
/* эта операция аналогична выражению
count = count - 3 */
// найдем остаток от деления на 8
count %= 8 // 5
/* эта операция аналогична выражению
count = count % 8 */
```

Важно помнить, что типы значений при этом должны быть одинаковыми. 

```swift
// целочисленные константы
let numOne = 19
let numTwo = 4
// константы, имеющие тип числа с плавающей точкой тип Double
let numThree = 3.13
let numFour = 1.1

// операция сложения
let sum = numOne + numTwo // 23
// операция вычитания
let diff = numOne - numTwo // 15
// операция умножения
let mult = numOne * numTwo // 76
// операция деления
let qo = numOne / numTwo   // 4
```

Каким образом при делении константы равной 19, на константу равную 4, могло получиться 4? По логике результат деления должен был получиться равным 4,75! 
Ответ кроется в типе данных. Обе переменные имеют целочисленный тип данных Int, а значит, результат любой операции также будет иметь тип данных Int. При этом у результата деления просто ***отбрасывается дробная часть и никакого округления не происходит***. 

```swift
// операция сложения
let sumD = numThree + numFour  // 4,23
// операция вычитания
let diffD = numThree - numFour // 2,03
// операция умножения
let multD = numThree * numFour // 3,443
// операция деления
let qoD = numThree / numFour   // 2,84545454545455
```

### Shift operations. The shift left and shift right operations.Оператор сдвига
#Shift operations. Операции #сдвига влево и вправо принимают двоичную форму десятичного числа и сдвигают цифры влево или вправо, соответственно. Затем они возвращают новое двоичное число в десятичной форме. Например, десятичное число 14 в двоичном формате, дополненное до 8 цифр, будет равно 00001110. Сдвиг его влево на два разряда дает 00111000, что в десятичном формате составляет 56. Вот иллюстрация этого: 

<img alt="image" src="images/Shift operations.jpg"/>

Цифры, которые заполняют пустые места справа, становятся 0. Цифры, которые выпадают с конца слева, теряются.
Сдвиг вправо такой же, но цифры сдвигаются вправо.
Операторы для этих двух операций следующие:

```swift
Shift left: <<
1 << 3     // 8
Shift right: >>
32 >> 2   // 8 
```

Одна из причин использования сдвигов состоит в том, чтобы сделать умножение или деление более мощнее для двух простых чисел. Обратите внимание, `shifting left` на одного тоже, что и умножение на два, `shifting left` на два такое же, как умножение на четыре, и так далее.

Аналогичным образом, `Shift right` на одного тоже, что разделить на два, `Shift right` вправо на два, так же, как разделяться на четыре, и так далее.

В старые времена код часто использовал этот трюк, потому что переключение битов намного проще для процессора, чем сложное умножение и арифметики. Поэтому код был быстрее, если он использовал переключение.

These compute the #maximum and #minimum of two numbers 
respectively.
```swift
max(5, 10)     // 10
min(-5, -10)   // -10
```

### Приведение числовых типов данных 
Type #conversion. Стоит отметить, что на самом деле приведенные далее глобальные функции являются специальными методами-инициализаторами типов данных. Ранее мы говорили, что любые значения — это объекты и у них существуют запрограммированные действия — методы. У каждого типа данных есть специальный метод, называемый инициализатором. Он автоматически вызывается при создании нового объекта, а так как в результате вызова объекта «числовой тип данных» создается новый объект — «число», то и метод-инициализатор срабатывает. 

Инициализатор имеет собственное фиксированное обозначение — init, и для создания нового объекта определенного типа данных он вызывается так: 
`ИмяТипаДанных.init(_:)` 
например:  
`let numObj = Int.init(2) // 2`

В результате создается константа `numObj` целочисленного знакового типа Int со значением 2. 

С помощью вызова метода `#init(_:)` создается новый объект, описывающий некую сущность, которая соответствует используемому типу данных (число, строка и т. д.). Swift упрощает разработку, позволяя не писать имя метода-инициализатора:  
`ИмяТипаДанных(_:)`
например:  
`let numObj = Int(2) // 2`

В результате выполнения данного кода также будет объявлена константа типа Int со значением 2.
`Int(_:)` — преобразовывает переданное значение к типу данных Int. 

`Double(_:)` — преобразовывает переданное значение к типу данных Double. 

`Float(_:)` — преобразовывает переданное значение к типу данных Float. И для преобразования чисел в другие типы данных также используйте функции, совпадающие по названиям с типами. 

### Type conversion – превращение, конвертация

Вы не можете применять #конвертацию, к смешанным типам, необходимо приведение к одному типу
You need to say that you want to convert the type explicitly, явно

```swift
var integer: Int = 100
var decimal: Double = 12.5
integer = Int(decimal)          // 12 
```
Значения с плавающей запятой всегда усекаются, когда они используются для инициализации нового целочисленного значения таким образом. Это означает, что 4,75 превращается в 4, а -3,9 становится -3.

```swift
// переменная типа Int
let numberInt = 19
// переменная типа Double
let numberDouble = 3.13
// операция перемножения чисел
let resD = Double(numberInt) * numberDouble // 59,47
let resI = numberInt * Int(numberDouble)    // 57
```

### Способы записи числовых значений 
```swift
let decimalInteger = 17 
let binaryInteger = 0b10001      // 17 in binary notation 
let octalInteger = 0o21              // 17 in octal notation 
let hexadecimalInteger = 0x11  // 17 in hexadecimal notation 
```
-For decimal numbers

1.25e2 means 1.25 x 102, or 125.0.
2.
1.25e-2 means 1.25 x 10-2, or 0.0125.

-For hexadecimal numbers 

0xFp2 means 15 x 22, or 60.0.

0xFp-2 means 15 x 2-2, or 3.75.

Для удобства чтения можно делать так:
```swift
let paddedDouble = 000123.456 
let oneMillion = 1_000_000 
let justOverOneMillion = 1_000_000.000_000_1
```

Двоичная. Записываются с использованием префикса 0b перед числом. 

Восьмеричная. Числа записываются с использованием префикса 0o перед числом. 

Шестнадцатеричная. Числа записываются с использованием префикса 0х перед числом. 

Десятичная. Числа записываются без использования префикса в привычном и понятном для нас виде. 

```swift
// 17 в десятичном виде
let decimalInteger = 17
// 17 в двоичном виде
let binaryInteger = 0b10001
// 17 в восьмеричном виде
let octalInteger = 0o21
// 17 в шестнадцатеричном виде
let hexadecimalInteger = 0x11
```

Помимо этого, Swift позволяет использовать экспоненту. Для этого применяется символ `e` для десятичных чисел и символ `p` для шестнадцатеричных. 

Для десятичных чисел экспонента указывает на степень десятки: 1.25e2 соответствует 1,25 × 10^2, или 125,0. 
Для шестнадцатеричных чисел экспонента указывает на степень двойки: 0xFp-2 соответствует 15 × 2^–2, или 3,75. 

```swift
// десятичное число
let deciamlDouble = 12.1875 // 12,1875
// десятичное число с экспонентой
// соответствует выражению
// exponentDouble = 1.21875*101
let exponentDouble = 1.21875e1 // 12,1875 // шестнадцатеричное число с экспонентой // соответствует
// выражению hexadecimalDouble = 0xC.3*20 let hexadecimalDouble = 0xC.3p0 // 12,1875 
```

Для визуального отделения порядков числа можно использовать символ нижнего подчеркивания (underscore) 
```swift
let number = 1_000_000 // 1000000
let nextNumber = 1000000 // 1000000
```

### Тип данных Decimal numbers и точность операций. Дробные числа
22 / 7 #Дробные числа
This, you may be surprised to know, results in the number 3. This is because if you only use integers in your expression, Swift makes the result an integer also. In this case, the result is rounded down to the next integer, т.е округляется вниз в сторону целого числа.
You can tell Swift to use decimal numbers by changing it to the following:

22.0 / 7.0 - This time, the result is 3.142857142857143 as expected.

```swift
var myWallet: Double = 0
let incomeAfterOperation: Double = 0.1
```

Переменная myWallet описывает кошелек, а константа incomeAfterOperation — доход, который получает пользователь после совершения операции. Подразумевается, что в результате каждой операции общая сумма денег в кошельке увеличивается на 10 копеек. Предположим, что пользователь провел три операции, значит, значение кошелька нужно увеличить трижды 

```swift
myWallet += incomeAfterOperation
print(myWallet) //0.1

myWallet += incomeAfterOperation
print(myWallet) // 0.2

myWallet += incomeAfterOperation
print(myWallet) // 0.30000000000000004
```

Неожиданно, но по неизвестной пока причине третий вывод вместо 0.3 показал очень приближенное к нему, но все же отличающееся значение 0.30000000000000004. 

Ошибки в точности вычислений могут возникнуть, когда вы работаете с числами с плавающей точкой. В некоторых случаях компьютер не может точно представить число в двоичной форме и использует максимально близкое по значению. Мы видим это и в случае с incomeAfterOperation. При попытке перевести 0.1 в двоичный вид мы получим бесконечное число с повторяющимся набором символов 0011. Из-за ограничений на длину значения при проведении расчетов потребуется отбросить часть «бесконечного хвоста», что в результате и может привести к неожиданным ошибкам. 

<img alt="image" src="images/ошибки в числах с плавающей точкой.jpg"/>

Самое интересное, что примеров подобных чисел — бесконечное множество. И для любого из них с увеличением количества проведенных операций будет накапливаться ошибка, которая в конечном счете всплывет в расчетах. 
Когда ваша программа оперирует числовыми значениями, имеющими базу 10 (к примеру, денежные суммы), а вам критически важна точность вычислений, используйте тип данных `Decimal`. 

Если число записано с использованием только 0 и 1 (в двоичном виде) говорят, что оно имеет базу 2, то есть две цифры, с помощью которых представляется. У чисел в разных системах счисления разная база: у шестнадцатеричной — база 16, у десятичной — база 10 и т. д. 

Тип #Decimal отличается от Float и Double тем, что с его помощью можно с высокой точностью проводить операции с числами с плавающей точкой имеющими базу 10.

```swift
import Foundation
var decimalWallet: Decimal = 0
let income: Decimal = 0.1
decimalWallet += income
print(decimalWallet) // 0.1
decimalWallet += income
print(decimalWallet) // 0.2
decimalWallet += income
print(decimalWallet) // 0.3
```
Проблема решена, кол-во денег в кошельке ровно то, какое и ожидалось. 

Использование Decimal имеет свои недостатки. К примеру, этот тип данных работает значительно медленнее, чем Float или Double, а также потребляет больше памяти. Нет необходимости использовать Decimal постоянно. В случаях, когда значения могут быть измерены (физические величины), применяйте Float и Double. В случаях, когда значения могут быть сосчитаны (деньги), используйте `Decimal` 

### Строковые типы данных – String 
https://developer.apple.com/documentation/swift/string все про strings

Тип #String в Swift – это тип значения. Если вы создаете новое значение String, это значение String копируется, когда оно передается функции или методу или когда оно присваивается константе или переменной. В каждом случае создается новая копия существующего значения String, и передается или назначается новая копия, а не исходная версия.
Strings состоят из characters, и каждое слово состоит из отдельных символов.  Unicode http://unicode.org/ #графемы (grapheme) составные

```swift
let regionalIndicatorForUS: Character = "\u{1F1FA}\u{1F1F8}" 
// regionalIndicatorForUS is 🇺🇸
 
let characterA: Character = "a"
let characterDog: Character = "🐶"
let stringDog: String = "Dog"
// A character is simply a string of length one
```

Главная особенность Юникода в том, для любого существующего символа (практически всех естественных языков) есть однозначно определяющая последовательность чисел. То есть для любого символа существует уникальная кодовая последовательность, называемая кодовой точкой (code point). Так, к примеру, маленькая латинская a имеет кодовую точку 97 (в десятичной системе счисления) или 0х61 (в шестнадцатеричной системе счисления). 

Для работы с текстом предназначены два основных типа данных:
- тип `Character` предназначен для хранения отдельных символов;
- тип `String` предназначен для хранения произвольной текстовой информации. 
- 
Строковый литерал — это фиксированная последовательность текстовых символов, окруженная с обеих сторон двойными кавычками (""). 

Тип данных #Character позволяет хранить строковый литерал длиной в один символ. 
```swift
let char: Character = "a"
print(char) // а
Тип данных String 
// константа типа String
// тип данных задается явно
let stringOne: String = "Dragon"
```
Запомните, литерал, состоящий даже из одного символа, всегда неявно определяется как `String`. Для `Character` нужно явно указать тип данных 

#### Working with Characters

You can access the individual Character values for a String by iterating over the string with a for-in loop:
```swift
for character in "Dog!🐶" { 
print(character) 
} 
// D 
// o 
// g 
// ! 
// 🐶

let catCharacters: [Character] = ["C", "a", "t", "!", "🐱"] 
let catString = String(catCharacters) 
print(catString)   // Cat!🐱
```

#### Counting Characters. 
To retrieve a count of the Character values in a string, use the count property of the string, но не всегда это точный подсчет, так как символы могут быть из составных графем или одиночных, и еще от кодировки зависит.
```swift
let unusualMenagerie = "Koala 🐨, Snail 🐌, Penguin 🐧, Dromedary 🐪" 
print("unusualMenagerie has \(unusualMenagerie.count) characters") 
// Prints "unusualMenagerie has 40 characters"
```

Literal (Буквенный) – литеральное значение вводится или вставляется непосредственно в код без инициализаторов. Литеральная строка будет "hello", а литеральный массив будет [1, 2, 3]. Не литеральная строка может быть инициализирована с помощью String( ), а не литеральное целое число может быть инициализировано с homeTeamPoints + awayTeamPoints

Если не задать ясно Character, то автоматически будет тип String

#Инициализатор — это специальный метод, встроенный в тип данных, в данном случае в String, который позволяет создать хранилище нужного нам типа. 

Пустой строковый литерал — это строковый литерал, не содержащий символов. Другими словами, это пустая строка (кавычки без содержимого). Она также может быть проинициализирована в качестве значения. 

Пустая строка (кавычки без содержимого) также является строковым литералом. Вы можете передать ее в качестве значения параметру типа данных String 

```swift
// с помощью пустого строкового литерала
var emptyString = ""
// с помощью инициализатора типа String
var anotherEmptyString = String()
```

### Многострочные строковые литералы. Multi-line strings
В Swift можно писать строковые литералы в несколько строк, разделяя их символом переноса (нажатием клавиши Enter). В этом случае текст нужно обрамить с обеих сторон тремя двойными кавычками. При этом: открывающие и закрывающие тройки кавычек должны находиться на строке, не содержащей текст литерала: 

```swift
let bigString = """
  You can have a string
  that contains multiple
  lines
  by
  doing this.
  """
print(bigString)
```
Пробелы в таких строках сохраняются и можно делать свои отступы
```swift
let greeting = """
  It is traditional in programming to print "Hello, world!"
  """
```
Or escape character (\)

```swift
let greeting = "It is traditional in programming to print \"Hello, world!\ ""
```

You can use the escape character with other letters and symbols to produce specific results:

Double quote: `\"`

Single quote: `\’`

Backslash: `\\`

Tab: `\t`

Newline (go to the next line как Return): `\n`

<img alt="image" src="images/escape character.jpg"/>

#`lowercased()` приводит к строчному виду
#`uppercased()` приводит к заглавному виду

```swift
let name = “Johnny Appleseed”
if name.lowercased() == “joHnnY aPPleseeD”.lowercased() {
  print(”The two names are equal.”)
}
```
Console Output: `The two names are equal.`
 
Чтобы проверить, имеет ли строка конкретный префикс или суффикс строки, оба из которых принимают один аргумент типа String и возвращают логическое значение.

#`hasPrefix(_:)` проверяет начало строки 
#`hasSuffix(_:)` проверяет конец строки 

```swift
let greeting = “Hello, world!”
print(greeting.hasPrefix(”Hello”))
print(greeting.hasSuffix(”world!”))
print(greeting.hasSuffix(”World!”))
Console Output: true true false
```

```swift
let romeoAndJuliet = [ 
"Act 1 Scene 1: Verona, A public place", 
"Act 1 Scene 2: Capulet's mansion", 
"Act 1 Scene 3: A room in Capulet's mansion", 
"Act 1 Scene 4: A street outside Capulet's mansion", 
"Act 1 Scene 5: The Great Hall in Capulet's mansion", 
"Act 2 Scene 1: Outside Capulet's mansion", 
"Act 2 Scene 2: Capulet's orchard", 
"Act 2 Scene 3: Outside Friar Lawrence's cell", 
"Act 2 Scene 4: A street in Verona", 
"Act 2 Scene 5: Capulet's mansion", 
"Act 2 Scene 6: Friar Lawrence's cell" 
] 
```

You can use the `hasPrefix(_:)`

```swift
var act1SceneCount = 0 
   for scene in romeoAndJuliet { 
      if scene.hasPrefix("Act 1 ") { 
        act1SceneCount += 1 
      } 
   } 
print("There are \(act1SceneCount) scenes in Act 1") 
// Prints "There are 5 scenes in Act 1" 
```

Similarly, use the `hasSuffix(_:)`

```swift
var mansionCount = 0 
var cellCount = 0 
   for scene in romeoAndJuliet { 
       if scene.hasSuffix("Capulet's mansion") { 
          mansionCount += 1 
       } else if scene.hasSuffix("Friar Lawrence's cell") { 
          cellCount += 1 
       } 
   } 
print("\(mansionCount) mansion scenes; \(cellCount) cell scenes") 
// Prints "6 mansion scenes; 2 cell scenes"
```

***String and Character Equality***, “equal to” operator `== and the “not equal to” operator `!=`

```swift
let quotation = "We're a lot alike." 
let sameQuotation = "We're a lot alike." 
if quotation == sameQuotation { 
print("These two strings are considered equal") 
}
```

### Приведение к строковому типу данных
Как уже неоднократно говорилось, помимо непосредственной передачи литерала вы можете использовать специальную функцию, в данном случае `String(_:)`, для инициализации значения строкового типа 

```swift
// инициализация строкового значения
let notEmptyString = String("Hello, Troll!")

// константа типа Double
let someDoubleNumber = 74.22
// строка, созданная на основе константы типа Double
let someStringNumber = String(someDoubleNumber)  // "74.22"
```

### Объединение строк 
При необходимости вы можете объединять несколько строк в одну более длинную. Для этого существует два механизма: интерполяция и конкатенация. 

При #`интерполяции` происходит объединение строковых литералов, переменных, констант и выражений в едином строковом литерале `\(   )`

#Interpolation – вставка `\(…)`

Backslash  \ – обратная косая черта

```swift
var message = "Hello" + " my name is "
let name = "Matt
message = "Hello my name is \(name)!"    // "Hello my name is Matt!

let oneThird = 1.0 / 3.0
let oneThirdLongString = "One third is \(oneThird) as a decimal"

let a = 4
let b = 5
print(”If a is \(a) and b is \(b), then a + b equals \(a+b)”)

let listName = "Shopping"
var items = 14
myLabel.text = "There are \(items) items on your \(listName) list"
// The label displays "There are 14 items on your Shopping list"
 
func setLabel(_ label: UILabel, to text: String) {
  label.text = text
}
 
setLabel(myLabel, to: "There are \(items) items on your \(listName) list")

let multiplier = 3 
let message = "\(multiplier) times 2.5 is \(Double(multiplier) * 2.5)" 
// message is "3 times 2.5 is 7.5"

print(#"Write an interpolated string in Swift using \(multiplier)."#) 
// Prints "Write an interpolated string in Swift using \(multiplier)."

// переменная типа String
let name = "Дракон"
// константа типа String c использованием интерполяции
let hello = "Привет, меня зовут \(name)!"
// интерполяция с использованием выражения
let meters: Double = 10
let text = "Моя длина \(meters * 3.28) фута"
// выведем значения на консоль
print(hello) // Привет, меня зовут Дракон!
print(text) // Моя длина 32.8 фута
```

При #`конкатенации` происходит объединение нескольких строковых значений в одно с помощью оператора сложения `+`  

#Concatenation – Сцепление, склеивание, сложение строк

```swift
var message = "Hello" + " my name is "
let name = "Matt"
message += name  // "Hello my name is Matt 
```

you convert the Character to a String before you add it to message

```swift
let exclamationMark: Character = "!"
message += String(exclamationMark) // "Hello my name is Matt!
```
Or 
#`append(_:)` Adds a new element at the end of the array.
```swift
message.append(exclamationMark)
```

```swift
// константа типа String
let firstText = "Мой вес "
// переменная типа Double
let weight = 12.4
// константа типа String
let secondText = " тонны"
// конкатенация строк при инициализации значения новой переменной
let resultText = firstText + String(weight) + secondText
print(resultText) // Мой вес 12.4 тонны
```

В данном примере используется оператор сложения для объединения строковых значений. Тип данных константы weight не строковый, поэтому ее значение приводится к String с помощью соответствующей функции. 
Значения типа Character при конкатенации также должны преобразовываться к типу String. 

### Initializing an Empty String

```swift
var emptyString = ""                              // empty string literal 
var anotherEmptyString = String()        // initializer syntax 
// these two strings are both empty, and are equivalent to each other 
```

String value is empty by checking its Boolean #`isEmpty` property:

```swift
if emptyString.isEmpty { 
print("Nothing to see here") 
} 
// Prints "Nothing to see here"
```

Используйте свойство #`startIndex` для доступа к позиции первого `Character` строки. Свойство #`endIndex` – это позиция после последнего символа в строке. В результате свойство `endIndex` не является допустимым аргументом для нижнего индекса строки. Если строка пуста, `startIndex` и `endIndex` равны. Вы получаете доступ к индексам до и после данного индекса, используя методы #`index(before :)` и #`index(after :)` класса String. Чтобы получить доступ к индексу, находящемуся дальше от данного индекса, вы можете использовать метод `index(_: offsetBy :)`

```swift
let greeting = "Guten Tag!" 
greeting[greeting.startIndex]   // G 
greeting[greeting.index(before: greeting.endIndex)]   // ! 
greeting[greeting.index(after: greeting.startIndex)]  // u 
let index = greeting.index(greeting.startIndex, offsetBy: 7) 
greeting[index]  // a
```

Attempting to access an index outside of a string’s range or a Character at an index outside of a string’s range will trigger a runtime error.
```swift
greeting[greeting.endIndex] // Error 
greeting.index(after: greeting.endIndex) // Error 
```

Используйте свойство #`indices`, чтобы получить доступ ко всем индексам отдельных символов в строке.

```swift
for index in greeting.indices { 
print("\(greeting[index]) ", terminator: "") 
}  // Prints "G u t e n T a g ! "
```

### Inserting and Removing – Вставка и удаление
Чтобы вставить один символ в строку по указанному индексу, используйте метод #`insert(_: at :)`, а для вставки содержимого другой строки по указанному индексу используйте метод `insert (contentsOf: at :)`

```swift
var welcome = "hello" 
welcome.insert("!", at: welcome.endIndex) 
// welcome now equals "hello!" 

welcome.insert(contentsOf: " there", at: welcome.index(before: welcome.endIndex)) 
// welcome now equals "hello there!" 
```

Чтобы удалить один символ из строки по указанному индексу, используйте метод #`remove(at :)`, а для удаления подстроки в указанном диапазоне используйте метод `removeSubrange (_ :)`:
```swift
welcome.remove(at: welcome.index(before: welcome.endIndex)) 
// welcome now equals "hello there" 
let range = welcome.index(welcome.endIndex, offsetBy: -6)..<welcome.endIndex 
welcome.removeSubrange(range) 
// welcome now equals "hello"
```

### Юникод в строковых типах данных 

<img alt="image" src="images/name.jpg"/>

<img alt="image" src="images/name.jpg"/>

```swift

```

```swift

```

```swift

```

---
[К оглавлению](#contents)
###  <a id="chapter3" /> Глава №3. 


<img alt="image" src="images/name.jpg"/>

<img alt="image" src="images/name.jpg"/>

<img alt="image" src="images/name.jpg"/>

```swift

```

```swift

```

```swift

```

---
[К оглавлению](#contents)
###  <a id="chapter4" /> Глава №4. 


<img alt="image" src="images/name.jpg"/>

<img alt="image" src="images/name.jpg"/>

<img alt="image" src="images/name.jpg"/>

```swift

```

```swift

```

```swift

```

---
[К оглавлению](#contents)
###  <a id="chapter5" /> Глава №5. 


<img alt="image" src="images/name.jpg"/>

<img alt="image" src="images/name.jpg"/>

<img alt="image" src="images/name.jpg"/>

```swift

```

```swift

```

```swift

```

---
[К оглавлению](#contents)
###  <a id="chapter6" /> Глава №6. 


<img alt="image" src="images/name.jpg"/>

<img alt="image" src="images/name.jpg"/>

<img alt="image" src="images/name.jpg"/>

```swift

```

```swift

```

```swift

```

---
[К оглавлению](#contents)
###  <a id="chapter7" /> Глава №7. 



---
[К оглавлению](#contents)
###  <a id="chapter8" /> Глава №8. 



---
[К оглавлению](#contents)
###  <a id="chapter9" /> Глава №9. 



---
[К оглавлению](#contents)
###  <a id="chapter10" /> Глава №10. 



---
[К оглавлению](#contents)
###  <a id="chapter11" /> Глава №11. 



---
[К оглавлению](#contents)
###  <a id="chapter12" /> Глава №12. 



---
[К оглавлению](#contents)
###  <a id="chapter13" /> Глава №13. 



---
[К оглавлению](#contents)
###  <a id="chapter14" /> Глава №14. 



---
[К оглавлению](#contents)
###  <a id="chapter15" /> Глава №15. 



---
[К оглавлению](#contents)
###  <a id="chapter16" /> Глава №16. 



---
[К оглавлению](#contents)
###  <a id="chapter17" /> Глава №17. 



---
[К оглавлению](#contents)
###  <a id="chapter18" /> Глава №18. 



---
[К оглавлению](#contents)
###  <a id="chapter19" /> Глава №19. 



---
[К оглавлению](#contents)
###  <a id="chapter20" /> Глава №20. 



---
[К оглавлению](#contents)
###  <a id="chapter21" /> Глава №21. 



---
[К оглавлению](#contents)
###  <a id="chapter22" /> Глава №22. 



---
[К оглавлению](#contents)
###  <a id="chapter23" /> Глава №23. 



---
[К оглавлению](#contents)
###  <a id="chapter24" /> Глава №24. 



---
[К оглавлению](#contents)
###  <a id="chapter25" /> Глава №25. 



---
[К оглавлению](#contents)
###  <a id="chapter26" /> Глава №26. 



---
[К оглавлению](#contents)
###  <a id="chapter27" /> Глава №27. 

